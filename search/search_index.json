{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Go Language Learning Repository","text":"<p>Welcome! This repository is a personal journey through the foundations of the Go programming language, organized for easy exploration.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>Go_Foundations/\n    01_Basics/\n        main.go                # Basic syntax and Hello World\n    02_Constants_and_Types/\n        main.go                # Constants, types, and variables\n    03_Control_Structures/\n        main.go                # If, for, switch, etc.\n    04_Functions/\n        main.go                # Functions and parameters\n    05_Slices_and_Arrays/\n        main.go                # Slices, arrays, and operations\n    06_Maps/\n        main.go                # Maps and key-value usage\n    07_Structs/\n        main.go                # Structs and basic OOP\n    projects/\n        arithmetic.go          # Arithmetic operations\n        even.go                # Even number checker\n        hello.go               # Custom Hello World\n        quiz.go                # Simple quiz app\n        vote.go                # Voting logic example\n        ...                    # More small projects and experiments\ndocs/\n    advice.md                # Learning advice and tips\n    roadmap.md               # Suggested learning path\n</code></pre>"},{"location":"#key-highlights","title":"Key Highlights","text":"<ul> <li>Go_Foundations/: Step-by-step folders for each major Go topic, each with a focused <code>main.go</code>.</li> <li>projects/: Contains practical mini-projects and exercises. This is the best place to review my applied learning and coding style.</li> <li>docs/: Advice and roadmap for my learning process.</li> </ul>"},{"location":"#how-to-run","title":"How to Run","text":"<p>Make sure you have Go installed (recommended: Go 1.20+).</p> <p>To run any example:</p> <pre><code>cd Go_Foundations/01_Basics\ngo run main.go\n</code></pre> <p>Or for a project:</p> <pre><code>cd Go_Foundations/projects\ngo run quiz.go\n</code></pre>"},{"location":"#about","title":"About","text":"<p>Created and maintained by Njoxpy.</p>"},{"location":"advice/","title":"Advice","text":""},{"location":"advice/#golang","title":"Golang","text":"<ul> <li>start with golang tour https://go.dev/tour/welcome/1</li> <li>for api development use the alex edwards api dev side.</li> </ul>"},{"location":"advice/#note","title":"NOTE","text":"<ul> <li>Dedicate 1 hour to 2 hours a day.type everthing.</li> <li>Disable copilot or any AI stuffs unless you want them to teach you or explain further.Here\u2019s a more documentation-style version of your text:</li> </ul>"},{"location":"advice/#golang-learning-guide","title":"Golang Learning Guide","text":""},{"location":"advice/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Complete the Go Tour: https://go.dev/tour/welcome/1</p> </li> <li> <p>Provides a comprehensive introduction to Go\u2019s basics and core concepts.</p> </li> <li> <p>For API Development, follow Alex Edwards\u2019 Go API development tutorials.</p> </li> <li> <p>Focuses on practical, real-world API building in Go.</p> </li> </ol>"},{"location":"advice/#recommended-practices","title":"Recommended Practices","text":"<ul> <li>Daily Practice: Allocate 1\u20132 hours each day to coding exercises.</li> <li>Manual Typing: Type all code manually to reinforce learning and retention.</li> <li>AI Tools: Disable Copilot or other AI assistants unless used explicitly for explanations or clarifications.</li> </ul> <pre><code>python3 -m venv venv\n\n# Activate the virtual environment\nsource venv/bin/activate\n</code></pre>"},{"location":"docs/","title":"Docs","text":""},{"location":"docs/#basic-types-in-go","title":"Basic Types in Go","text":"<p>Go provides a set of basic types that are commonly used in programs:</p> <ul> <li> <p>Boolean: <code>bool</code></p> </li> <li> <p>Strings: <code>string</code></p> </li> <li> <p>Signed integers: <code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code></p> </li> <li> <p>Unsigned integers: <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>uintptr</code></p> </li> <li> <p>Aliases: <code>byte</code> \u2192 alias for <code>uint8</code> <code>rune</code> \u2192 alias for <code>int32</code> (represents a Unicode code point)</p> </li> <li> <p>Floating-point numbers: <code>float32</code>, <code>float64</code></p> </li> <li> <p>Complex numbers: <code>complex64</code>, <code>complex128</code></p> </li> </ul> <p>The following example demonstrates variables of various types. It also shows how variable declarations can be grouped together in a block, similar to how imports are grouped.</p> <p>Note: The types <code>int</code>, <code>uint</code>, and <code>uintptr</code> are typically 32 bits on 32-bit systems and 64 bits on 64-bit systems. Use <code>int</code> for general-purpose integers unless you have a specific reason to choose a fixed-size or unsigned integer.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/cmplx\"\n)\n\nvar (\n    ToBe   bool       = false\n    MaxInt uint64     = 1&lt;&lt;64 - 1\n    z      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n\nfunc main() {\n    fmt.Printf(\"Type: %T Value: %v\\n\", ToBe, ToBe)\n    fmt.Printf(\"Type: %T Value: %v\\n\", MaxInt, MaxInt)\n    fmt.Printf(\"Type: %T Value: %v\\n\", z, z)\n}\n</code></pre> <p>Output example:</p> <pre><code>Type: bool Value: false\nType: uint64 Value: 18446744073709551615\nType: complex128 Value: (2+3i)\n</code></pre>"},{"location":"docs/#zero-values-in-go","title":"Zero Values in Go","text":"<p>In Go, variables declared without an explicit initial value are automatically assigned a zero value. The zero value depends on the type of the variable:</p> <ul> <li>Numeric types \u2192 <code>0</code></li> <li>Boolean type \u2192 <code>false</code></li> <li>String type \u2192 <code>\"\"</code> (empty string)</li> </ul> <p>Example:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i int      // zero value is 0\n    var f float64  // zero value is 0\n    var b bool     // zero value is false\n    var s string   // zero value is \"\"\n\n    fmt.Printf(\"%v %v %v %q\\n\", i, f, b, s)\n}\n</code></pre> <p>Output:</p> <pre><code>0 0 false \"\"\n</code></pre> <p>This feature ensures that all variables in Go always have a well-defined initial value, even if you don\u2019t explicitly assign one.</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#overview","title":"\ud83d\uddd3\ufe0f OVERVIEW","text":"<p>Goal: Master Go fundamentals and backend essentials in 3 weeks Resources: Tour of Go, Go docs, Go Playground, VS Code or GoLand Tools: Go 1.22+, Git, Postman (for backend testing later) Style: Learn \u2192 Practice \u2192 Build mini-project</p>"},{"location":"roadmap/#week-1-foundation-core-syntax","title":"\ud83e\udded WEEK 1 \u2013 Foundation &amp; Core Syntax","text":"<p>Focus: Understand Go basics, variables, flow control, and syntax fluency.</p>"},{"location":"roadmap/#day-12-welcome-basics-tour-section-1","title":"\ud83d\udcd8 Day 1\u20132: Welcome &amp; Basics (Tour Section 1)","text":"<ul> <li>Do: Tour Part 1 (5 parts)</li> <li> <p>Learn:</p> </li> <li> <p>Hello, World</p> </li> <li>Go Playground &amp; setup locally</li> <li> <p>How Go runs programs</p> </li> <li> <p>Practice:</p> </li> <li> <p>Write a \u201cHello\u201d program printing your name, date, and favorite language.</p> </li> <li>Run it both online and locally.</li> </ul>"},{"location":"roadmap/#day-35-packages-variables-functions-17-parts","title":"\ud83d\udcd8 Day 3\u20135: Packages, Variables, Functions (17 parts)","text":"<ul> <li> <p>Learn:</p> </li> <li> <p>Importing packages</p> </li> <li>Exported names</li> <li>Variables, constants, and short declarations</li> <li> <p>Functions and multiple return values</p> </li> <li> <p>Practice:</p> </li> <li> <p>Write small functions that calculate BMI, area of circle, etc.</p> </li> <li>Experiment with package-level vs function-level variables.</li> </ul>"},{"location":"roadmap/#day-67-weekend-deep-dive","title":"\ud83d\udcd8 Day 6\u20137 (Weekend Deep Dive)","text":"<ul> <li>Review all lessons with custom notes.</li> <li> <p>Mini-Project #1: CLI Utility</p> </li> <li> <p>Build a small Go command-line tool:</p> <p><code>go run greet.go --name=\"Njox\"</code></p> <p>\u2192 Outputs \u201cHello Njox! Welcome to Go!\u201d</p> </li> <li> <p>Add flags and simple error handling.</p> </li> </ul>"},{"location":"roadmap/#week-2-data-types-control-logic","title":"\ud83e\udded WEEK 2 \u2013 Data Types &amp; Control Logic","text":"<p>Focus: Strengthen logic skills and learn Go\u2019s composite types.</p>"},{"location":"roadmap/#day-89-flow-control-14-parts","title":"\ud83d\udcd8 Day 8\u20139: Flow Control (14 parts)","text":"<ul> <li> <p>Learn:</p> </li> <li> <p>for loops</p> </li> <li> <p>if/else, switch, defer</p> </li> <li> <p>Practice:</p> </li> <li> <p>Implement a fizzbuzz program with <code>for</code> and <code>switch</code></p> </li> <li>Try multiple <code>defer</code> statements and observe execution order</li> </ul>"},{"location":"roadmap/#day-1013-more-types-27-parts","title":"\ud83d\udcd8 Day 10\u201313: More Types (27 parts)","text":"<ul> <li> <p>Learn:</p> </li> <li> <p>Pointers</p> </li> <li>Structs, arrays, slices, maps</li> <li> <p>Range, append, make</p> </li> <li> <p>Practice:</p> </li> <li> <p>Build a \u201cStudent Record\u201d app with struct + slice of structs</p> </li> <li>Write functions to add, list, and search students</li> </ul>"},{"location":"roadmap/#day-1415-weekend-project","title":"\ud83d\udcd8 Day 14\u201315 (Weekend Project)","text":"<ul> <li> <p>Mini-Project #2: JSON Data API (local)</p> </li> <li> <p>Use structs and slices to hold mock data</p> </li> <li>Use <code>encoding/json</code> to encode/decode data</li> <li> <p>Expose simple endpoints via <code>net/http</code></p> <p><code>GET /students POST /students</code></p> </li> <li> <p>Use Postman or curl to test</p> </li> </ul>"},{"location":"roadmap/#week-3-oop-concurrency-backend-integration","title":"\ud83e\udded WEEK 3 \u2013 OOP, Concurrency &amp; Backend Integration","text":"<p>Focus: Advanced features \u2014 methods, interfaces, generics, and goroutines.</p>"},{"location":"roadmap/#day-1618-methods-interfaces-26-parts","title":"\ud83d\udcd8 Day 16\u201318: Methods &amp; Interfaces (26 parts)","text":"<ul> <li> <p>Learn:</p> </li> <li> <p>Methods on structs</p> </li> <li>Interfaces and polymorphism</li> <li> <p>Type assertions</p> </li> <li> <p>Practice:</p> </li> <li> <p>Create a simple interface like:</p> <p><code>go type Notifier interface {     Notify(msg string) }</code></p> </li> <li> <p>Implement for <code>EmailNotifier</code> and <code>SMSNotifier</code>.</p> </li> </ul>"},{"location":"roadmap/#day-19-generics-3-parts","title":"\ud83d\udcd8 Day 19: Generics (3 parts)","text":"<ul> <li>Learn: Type parameters and constraints.</li> <li> <p>Practice:</p> </li> <li> <p>Build a generic <code>Sum()</code> or <code>Filter()</code> function for integers and floats.</p> </li> </ul>"},{"location":"roadmap/#day-2021-concurrency-11-parts","title":"\ud83d\udcd8 Day 20\u201321: Concurrency (11 parts)","text":"<ul> <li> <p>Learn:</p> </li> <li> <p>Goroutines</p> </li> <li>Channels and buffered channels</li> <li> <p>Select statement</p> </li> <li> <p>Practice:</p> </li> <li> <p>Write a program that fetches URLs concurrently and prints response times.</p> </li> </ul>"},{"location":"roadmap/#day-2223-weekend-capstone","title":"\ud83d\udcd8 Day 22\u201323 (Weekend Capstone)","text":"<ul> <li> <p>Final Project: Mini Go REST API Backend</p> </li> <li> <p>Use Gin or Fiber</p> </li> <li> <p>Endpoints:</p> <ul> <li><code>GET /tasks</code> \u2192 list tasks</li> <li><code>POST /tasks</code> \u2192 add task</li> <li><code>DELETE /tasks/:id</code> \u2192 delete task</li> </ul> </li> <li> <p>Add concurrency feature: log each request in a separate goroutine</p> </li> <li>Add JSON storage (no database yet)</li> </ul>"},{"location":"roadmap/#final-review-day-2421-overlap-optional","title":"\ud83c\udf93 Final Review (Day 24\u201321 overlap optional)","text":"<ul> <li>Revisit difficult concepts (interfaces, concurrency)</li> <li>Push all projects to GitHub</li> <li>Try running your API as a service using <code>go run main.go</code></li> <li>Optional: add SQLite or MongoDB to API</li> </ul>"},{"location":"roadmap/#tips","title":"\ud83d\udca1 Tips","text":"<ul> <li>Use <code>go fmt</code>, <code>go run</code>, and <code>go test</code> frequently.</li> <li>Read code from Go by Example.</li> <li>Write at least 20\u201330 lines of Go code daily.</li> <li>On weekends, reflect on what you\u2019ve built.</li> </ul>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/","title":"Overview","text":""},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#packages-in-go","title":"Packages in Go","text":"<p>Every Go program is composed of packages. Execution always begins in the <code>main</code> package.</p> <p>This example uses the packages with import paths <code>\"fmt\"</code> and <code>\"math/rand\"</code>.</p> <p>By convention, the package name matches the last element of its import path. For example, files in the <code>\"math/rand\"</code> package start with the declaration:</p> <pre><code>package rand\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#example","title":"Example:","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n)\n\nfunc main() {\n    fmt.Println(\"My favorite number is\", rand.Intn(10))\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#imports","title":"Imports","text":"<p>In Go, imports can be grouped into a factored import statement, enclosed in parentheses. This is the preferred style for readability and organization.</p>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#example-factored-import","title":"Example (factored import):","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    fmt.Printf(\"Now you have %g problems.\\n\", math.Sqrt(7))\n}\n</code></pre> <p>Output:</p> <pre><code>Now you have 2.6457513110645907 problems.\nProgram exited.\n</code></pre> <p>Alternatively, you can use multiple single-line import statements, though it\u2019s less common:</p> <pre><code>import \"fmt\"\nimport \"math\"\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#exported-names","title":"Exported Names","text":"<p>In Go, a name is exported if it begins with a capital letter.</p> <p>For example:</p> <ul> <li><code>Pizza</code> \u2014 exported</li> <li><code>Pi</code> \u2014 exported from the <code>math</code> package</li> <li><code>pizza</code> and <code>pi</code> \u2014 not exported (private to the package)</li> </ul> <p>When you import a package, you can access only its exported names. Unexported names (those starting with a lowercase letter) are not accessible from outside the package.</p>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#example-with-error","title":"Example (with error):","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    fmt.Println(math.pi) // Error: cannot refer to unexported name math.pi\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#fixed-version","title":"Fixed version:","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    fmt.Println(math.Pi) // Works correctly\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#go-language-basics","title":"Go Language Basics","text":""},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#functions","title":"Functions","text":"<p>A function in Go can take zero or more arguments.</p> <p>In the following example, the <code>add</code> function takes two parameters of type <code>int</code>. Notice that the type is written after the variable name.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc add(x int, y int) int {\n    return x + y\n}\n\nfunc main() {\n    fmt.Println(add(42, 13))\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#functions-continued","title":"Functions (continued)","text":"<p>When two or more consecutive parameters share a type, you can omit the type from all but the last. For example, instead of writing:</p> <pre><code>x int, y int\n</code></pre> <p>you can write:</p> <pre><code>x, y int\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc add(x, y int) int {\n    return x + y\n}\n\nfunc main() {\n    fmt.Println(add(42, 13))\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#multiple-results","title":"Multiple Results","text":"<p>A function can return multiple values. Here, the <code>swap</code> function returns two strings.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc swap(x, y string) (string, string) {\n    return y, x\n}\n\nfunc main() {\n    a, b := swap(\"hello\", \"world\")\n    fmt.Println(a, b)\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#named-return-values","title":"Named Return Values","text":"<p>Go allows you to name return values. These are treated as variables defined at the top of the function. A naked return statement (without arguments) returns these named values automatically.</p> <p>Note: Naked returns should be used only in short, simple functions to preserve readability.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc split(sum int) (x, y int) {\n    x = sum * 4 / 9\n    y = sum - x\n    return\n}\n\nfunc main() {\n    fmt.Println(split(17))\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#variables","title":"Variables","text":"<p>The <code>var</code> statement declares a list of variables, with the type coming last.</p> <p>A <code>var</code> declaration can appear at both package and function level.</p> <pre><code>package main\n\nimport \"fmt\"\n\nvar c, python, java bool\n\nfunc main() {\n    var i int\n    fmt.Println(i, c, python, java)\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#variables-with-initializers","title":"Variables with Initializers","text":"<p>A <code>var</code> declaration can include initializers. If an initializer is provided, the type can be omitted since it will be inferred from the value.</p> <pre><code>package main\n\nimport \"fmt\"\n\nvar i, j int = 1, 2\n\nfunc main() {\n    var c, python, java = true, false, \"no!\"\n    fmt.Println(i, j, c, python, java)\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#short-variable-declarations","title":"Short Variable Declarations","text":"<p>Inside a function, you can use the shorthand <code>:=</code> to declare and initialize variables.</p> <p>Outside functions, <code>:=</code> cannot be used because all statements must start with a keyword (like <code>var</code> or <code>func</code>).</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i, j int = 1, 2\n    k := 3\n    c, python, java := true, false, \"no!\"\n\n    fmt.Println(i, j, k, c, python, java)\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#basic-types","title":"Basic Types","text":"<p>Go\u2019s basic data types include:</p> <ul> <li><code>bool</code></li> <li><code>string</code></li> <li> <p>Numeric types:</p> </li> <li> <p>Signed integers: <code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code></p> </li> <li>Unsigned integers: <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>uintptr</code></li> <li>Aliases: <code>byte</code> (for <code>uint8</code>), <code>rune</code> (for <code>int32</code>, representing Unicode code points)</li> <li>Floating point: <code>float32</code>, <code>float64</code></li> <li>Complex numbers: <code>complex64</code>, <code>complex128</code></li> </ul> <p>Typically, <code>int</code>, <code>uint</code>, and <code>uintptr</code> are 32 bits on 32-bit systems and 64 bits on 64-bit systems. Use <code>int</code> unless you have a specific reason to choose another type.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/cmplx\"\n)\n\nvar (\n    ToBe   bool       = false\n    MaxInt uint64     = 1&lt;&lt;64 - 1\n    z      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n\nfunc main() {\n    fmt.Printf(\"Type: %T Value: %v\\n\", ToBe, ToBe)\n    fmt.Printf(\"Type: %T Value: %v\\n\", MaxInt, MaxInt)\n    fmt.Printf(\"Type: %T Value: %v\\n\", z, z)\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#zero-values","title":"Zero Values","text":"<p>Variables declared without an explicit initializer are assigned their zero value:</p> <ul> <li><code>0</code> for numeric types</li> <li><code>false</code> for booleans</li> <li><code>\"\"</code> (empty string) for strings</li> </ul> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i int\n    var f float64\n    var b bool\n    var s string\n    fmt.Printf(\"%v %v %v %q\\n\", i, f, b, s)\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#type-conversions","title":"Type Conversions","text":"<p>Use <code>T(v)</code> to convert the value <code>v</code> to type <code>T</code>.</p> <p>Example:</p> <pre><code>var i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n</code></pre> <p>Or, more simply:</p> <pre><code>i := 42\nf := float64(i)\nu := uint(f)\n</code></pre> <p>Unlike C, Go requires explicit type conversions.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    var x, y int = 3, 4\n    var f float64 = math.Sqrt(float64(x*x + y*y))\n    var z uint = uint(f)\n    fmt.Println(x, y, z)\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#type-inference","title":"Type Inference","text":"<p>If you declare a variable without specifying its type (using <code>:=</code> or <code>var =</code>), Go infers the type from the value.</p> <ul> <li>When the value has a type, the new variable takes that type.</li> <li>When the value is an untyped constant, Go assigns a suitable default type.</li> </ul> <p>Examples:</p> <pre><code>var i int\nj := i // j is an int\n\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    v := 42 // change me!\n    fmt.Printf(\"v is of type %T\\n\", v)\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#constants","title":"Constants","text":"<p>Constants are declared like variables, but with the <code>const</code> keyword. They can be character, string, boolean, or numeric values. You cannot use <code>:=</code> for constants.</p> <pre><code>package main\n\nimport \"fmt\"\n\nconst Pi = 3.14\n\nfunc main() {\n    const World = \"\u4e16\u754c\"\n    fmt.Println(\"Hello\", World)\n    fmt.Println(\"Happy\", Pi, \"Day\")\n\n    const Truth = true\n    fmt.Println(\"Go rules?\", Truth)\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#numeric-constants","title":"Numeric Constants","text":"<p>Numeric constants are high-precision values. An untyped constant takes on the type required by its context.</p> <pre><code>package main\n\nimport \"fmt\"\n\nconst (\n    // Create a huge number by shifting 1 left 100 places (1 followed by 100 zeroes)\n    Big = 1 &lt;&lt; 100\n    // Shift it right again by 99, resulting in 1&lt;&lt;1 or 2\n    Small = Big &gt;&gt; 99\n)\n\nfunc needInt(x int) int { return x*10 + 1 }\nfunc needFloat(x float64) float64 {\n    return x * 0.1\n}\n\nfunc main() {\n    fmt.Println(needInt(Small))\n    fmt.Println(needFloat(Small))\n    fmt.Println(needFloat(Big))\n}\n</code></pre>"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#congratulations","title":"\ud83c\udf89 Congratulations!","text":"<p>You\u2019ve completed this Go basics module. You can now proceed to the next lesson or review previous ones to strengthen your understanding.</p>"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/","title":"Overview","text":""},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#hello","title":"Hello, \u4e16\u754c","text":"<p>Welcome to the Go Programming Language Tour \u2014 an interactive guide designed to help you learn Go step by step.</p>"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#navigating-the-tour","title":"Navigating the Tour","text":"<p>The tour is divided into several modules. You can access them by clicking \u201cA Tour of Go\u201d at the top-left of the page.</p> <p>To view the table of contents at any time, click the menu icon in the top-right corner.</p> <p>Each module contains a series of slides and hands-on exercises. Use the navigation options below to move through the tour:</p> <ul> <li>Previous or PageUp \u2192 Go to the previous page</li> <li>Next or PageDown \u2192 Move to the next page</li> </ul>"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#running-and-editing-code","title":"Running and Editing Code","text":"<p>The tour is interactive \u2014 try it now! Click Run (or press Shift + Enter) to compile and execute the program on a remote server. The output will appear directly below the code editor.</p> <p>Each example demonstrates a specific feature or concept in Go. These programs are designed as starting points for your own experimentation \u2014 feel free to edit the code and run it again.</p> <p>You can also:</p> <ul> <li>Click Format (shortcut: Ctrl + Enter) to format your code using the <code>gofmt</code> tool.</li> <li>Toggle syntax highlighting by clicking the Syntax button.</li> </ul> <p>When you\u2019re ready to continue, click the right arrow below or press PageDown.</p>"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#example-program","title":"Example Program","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, \u4e16\u754c\")\n}\n</code></pre>"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#go-in-your-language","title":"Go in Your Language","text":"<p>The tour is available in multiple languages:</p> <ul> <li>Portugu\u00eas do Brasil</li> <li>Catal\u00e0</li> <li>\u4e2d\u6587\uff08\u7b80\u4f53\uff09</li> <li>\u010cesky</li> <li>Bahasa Indonesia</li> <li>\u65e5\u672c\u8a9e</li> <li>Polski</li> <li>Espa\u00f1ol</li> <li>\u0e20\u0e32\u0e29\u0e32\u0e44\u0e17\u0e22</li> <li>\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u043e\u044e</li> </ul> <p>Click Next or press PageDown to continue.</p>"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#go-offline-optional","title":"Go Offline (Optional)","text":"<p>You can also take this tour offline. The offline version runs locally on your computer and doesn\u2019t require internet access.</p> <p>To set it up:</p> <ol> <li>Install Go on your system.</li> <li>Run the following command:</li> </ol> <p><code>bash    go install golang.org/x/website/tour@latest</code></p> <p>This installs the tour binary in your <code>GOPATH/bin</code> directory.</p> <p>Then, launch the tour program to open a browser window with your local version of the tour.</p> <p>(You can, of course, continue using this online version instead.)</p>"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#the-go-playground","title":"The Go Playground","text":"<p>This tour is powered by the Go Playground, a web service hosted on golang.org.</p> <p>Here\u2019s how it works:</p> <ul> <li>The Playground receives your Go program, compiles, links, and runs it securely inside a sandbox.</li> <li>It then returns the output to your browser.</li> </ul>"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#playground-limitations","title":"Playground Limitations:","text":"<ul> <li>The time inside the playground always starts at 2009-11-10 23:00:00 UTC \u2014 a fixed reference that helps ensure consistent program output.</li> <li>Programs have execution time, CPU, and memory limits.</li> <li>Programs cannot access external network hosts.</li> <li>The Playground always uses the latest stable release of Go.</li> </ul> <p>To learn more, read Inside the Go Playground.</p>"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    fmt.Println(\"Welcome to the playground!\")\n    fmt.Println(\"The time is\", time.Now())\n}\n</code></pre>"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#congratulations","title":"Congratulations","text":"<p>You\u2019ve completed the first module of the Go Tour!</p> <p>Click A Tour of Go at the top to explore more topics, or proceed directly to the next lesson to continue your journey.</p>"},{"location":"controlflowstatements/","title":"Overview","text":""},{"location":"controlflowstatements/#for-loops-in-go","title":"For Loops in Go","text":"<p>Go has only one looping construct: the <code>for</code> loop.</p> <p>The basic <code>for</code> loop consists of three components separated by semicolons:</p> <ol> <li>Initialization statement \u2013 executed before the first iteration</li> <li>Condition expression \u2013 evaluated before every iteration</li> <li>Post statement \u2013 executed at the end of each iteration</li> </ol>"},{"location":"controlflowstatements/#how-it-works","title":"How it Works","text":"<ul> <li>The init statement is commonly a short variable declaration.   Variables declared here are visible only within the scope of the for loop.</li> <li>The loop continues to execute as long as the condition is true.</li> <li>Once the condition evaluates to <code>false</code>, the loop stops.</li> <li> <p>Unlike C, Java, or JavaScript:</p> </li> <li> <p>There are no parentheses around the components.</p> </li> <li>The curly braces <code>{}</code> are mandatory, even for single-line loops.</li> </ul>"},{"location":"controlflowstatements/#example","title":"Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    sum := 0\n    for i := 0; i &lt; 10; i++ {\n        sum += i\n    }\n    fmt.Println(sum)\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>i := 0</code> initializes the counter.</li> <li>The loop runs while <code>i &lt; 10</code>.</li> <li>After each iteration, <code>i++</code> increments <code>i</code> by 1.</li> <li>The loop accumulates the sum of numbers from 0 to 9.</li> </ul> <p>Output:</p> <pre><code>45\n</code></pre>"},{"location":"controlflowstatements/#for-continued","title":"For (continued)","text":"<p>In Go, the init and post statements in a <code>for</code> loop are optional. You can omit one or both, depending on the logic you need.</p>"},{"location":"controlflowstatements/#example_1","title":"Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    sum := 1\n    for ; sum &lt; 10; {\n        sum += sum\n    }\n    fmt.Println(sum)\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation","title":"Explanation","text":"<ul> <li>The init and post sections are left empty.</li> <li>Only the condition (<code>sum &lt; 10</code>) remains between the semicolons.</li> <li>This is perfectly valid Go syntax and works just like a while loop in other languages.</li> </ul> <p>The above example doubles the value of <code>sum</code> until it is no longer less than 10.</p>"},{"location":"controlflowstatements/#output","title":"Output","text":"<pre><code>16\n</code></pre>"},{"location":"controlflowstatements/#tip","title":"Tip","text":"<p>If both the init and post statements are omitted, the semicolons themselves can also be removed \u2014 turning it into Go\u2019s while-style loop:</p> <pre><code>for sum &lt; 10 {\n    sum += sum\n}\n</code></pre>"},{"location":"controlflowstatements/#for-continued_1","title":"For (continued)","text":"<p>The init and post statements in a Go <code>for</code> loop are optional. If you omit them, the <code>for</code> loop still works \u2014 it simply becomes more flexible, resembling a <code>while</code> loop in other languages.</p>"},{"location":"controlflowstatements/#example_2","title":"Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    sum := 1\n    for ; sum &lt; 10; {\n        sum += sum\n    }\n    fmt.Println(sum)\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_1","title":"Explanation","text":"<ul> <li>The init and post statements are left empty (<code>;</code> marks their positions).</li> <li> <p>This means:</p> </li> <li> <p>There is no initialization before the loop starts.</p> </li> <li>There is no automatic update after each iteration.</li> <li>The loop runs as long as the condition <code>sum &lt; 10</code> is <code>true</code>.</li> </ul> <p>Here\u2019s what happens step by step:</p> Step Value of <code>sum</code> Condition (<code>sum &lt; 10</code>) Action 1 1 true <code>sum += sum \u2192 2</code> 2 2 true <code>sum += sum \u2192 4</code> 3 4 true <code>sum += sum \u2192 8</code> 4 8 true <code>sum += sum \u2192 16</code> 5 16 false Loop ends"},{"location":"controlflowstatements/#output_1","title":"Output","text":"<pre><code>16\n</code></pre>"},{"location":"controlflowstatements/#key-insight","title":"Key Insight","text":"<p>When you omit both the init and post parts, the <code>for</code> loop in Go acts like a while loop in other languages.</p> <p>Equivalent while-style syntax in pseudocode:</p> <pre><code>for sum &lt; 10 {\n    sum += sum\n}\n</code></pre> <p>This demonstrates Go\u2019s flexibility \u2014 you can use <code>for</code> in multiple forms, including the traditional C-style loop or simplified while-like loops.</p>"},{"location":"controlflowstatements/#for-as-gos-while","title":"For as Go's \"While\"","text":"<p>In Go, there is no separate <code>while</code> loop. You can use a <code>for</code> loop without semicolons to achieve the same behavior.</p> <p>This makes the <code>for</code> loop Go\u2019s equivalent of <code>while</code> in other languages like C or Java.</p>"},{"location":"controlflowstatements/#example_3","title":"Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    sum := 1\n    for sum &lt; 1000 {\n        sum += sum\n    }\n    fmt.Println(sum)\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_2","title":"Explanation","text":"<ul> <li>The condition <code>sum &lt; 1000</code> is checked before each iteration.</li> <li>There are no init or post statements; the semicolons are omitted.</li> <li>The loop continues as long as the condition is true.</li> <li>Each iteration doubles the value of <code>sum</code>.</li> </ul>"},{"location":"controlflowstatements/#output_2","title":"Output","text":"<pre><code>1024\n</code></pre>"},{"location":"controlflowstatements/#key-insight_1","title":"Key Insight","text":"<ul> <li> <p>Go\u2019s <code>for</code> loop is versatile:</p> </li> <li> <p>Traditional <code>for</code> with <code>init; condition; post</code></p> </li> <li><code>for</code> as a while loop (<code>for condition { ... }</code>)</li> <li>Infinite loop (<code>for { ... }</code>)</li> </ul> <p>This flexibility makes Go loops simple and powerful.</p> <p>Forever If you omit the loop condition it loops forever, so an infinite loop is compactly expressed.</p> <pre><code>package main\n\nfunc main() {\n\n    for {\n\n    }\n\n}\n</code></pre>"},{"location":"controlflowstatements/#if-statements","title":"If Statements","text":"<p>In Go, <code>if</code> statements are similar to <code>for</code> loops in syntax:</p> <ul> <li>The condition does not require parentheses <code>()</code>.</li> <li>Braces <code>{}</code> are required, even for single-line blocks.</li> </ul>"},{"location":"controlflowstatements/#example_4","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc sqrt(x float64) string {\n    if x &lt; 0 {\n        return sqrt(-x) + \"i\"\n    }\n    return fmt.Sprint(math.Sqrt(x))\n}\n\nfunc main() {\n    fmt.Println(sqrt(2), sqrt(-4))\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_3","title":"Explanation","text":"<ol> <li>The function <code>sqrt</code> computes the square root of <code>x</code>.</li> <li> <p>The <code>if</code> statement checks if <code>x</code> is negative:</p> </li> <li> <p>If yes, it recursively calls <code>sqrt</code> with <code>-x</code> and appends <code>\"i\"</code> to indicate an imaginary number.</p> </li> <li>If not, it returns the square root of <code>x</code> using <code>math.Sqrt</code>.</li> <li>The <code>fmt.Sprint</code> function converts the float result to a string for consistent return type.</li> </ol>"},{"location":"controlflowstatements/#output_3","title":"Output","text":"<pre><code>1.4142135623730951 2i\n</code></pre>"},{"location":"controlflowstatements/#key-points","title":"Key Points","text":"<ul> <li>Go allows inline <code>if</code> conditions without parentheses:</li> </ul> <p><code>go   if x &lt; 0 { ... }</code> * Braces are mandatory and define the scope of the conditional block. * Go supports recursive function calls as shown in the example.</p>"},{"location":"controlflowstatements/#if-statement-with-a-short-statement","title":"If Statement with a Short Statement","text":"<p>In Go, an <code>if</code> statement can include a short statement that runs before the condition.</p> <ul> <li>Variables declared in this short statement are only in scope within the <code>if</code> block.</li> <li>This is useful for computations that are only needed for the conditional check.</li> </ul>"},{"location":"controlflowstatements/#example_5","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc pow(x, n, lim float64) float64 {\n    if v := math.Pow(x, n); v &lt; lim {\n        return v\n    }\n    return lim\n}\n\nfunc main() {\n    fmt.Println(\n        pow(3, 2, 10),\n        pow(3, 3, 20),\n    )\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_4","title":"Explanation","text":"<ol> <li>The <code>if</code> statement starts with a short statement:</li> </ol> <p><code>go    v := math.Pow(x, n)</code></p> <p>This computes <code>x</code> raised to the power <code>n</code> and assigns it to <code>v</code>. 2. The condition <code>v &lt; lim</code> is evaluated immediately after the short statement. 3. <code>v</code> is only visible inside the <code>if</code> statement. 4. If <code>v &lt; lim</code>, the function returns <code>v</code>; otherwise, it returns <code>lim</code>.</p>"},{"location":"controlflowstatements/#output_4","title":"Output","text":"<pre><code>9 20\n</code></pre>"},{"location":"controlflowstatements/#key-points_1","title":"Key Points","text":"<ul> <li>Short statements in <code>if</code> allow clean, inline computation before the condition.</li> <li>Scope of variables declared this way is limited to the <code>if</code> block, which helps avoid polluting the outer scope.</li> </ul> <p>Example of limited scope:</p> <pre><code>if v := computeSomething(); v &gt; 10 {\n    fmt.Println(v) // OK\n}\n// fmt.Println(v) // Error: v is undefined here\n</code></pre>"},{"location":"controlflowstatements/#switch-statement","title":"Switch Statement","text":"<p>A <code>switch</code> statement in Go is a concise way to write a sequence of <code>if-else</code> statements.</p> <ul> <li>It runs the first case whose value matches the switch expression.</li> <li> <p>Unlike C, C++, Java, or JavaScript:</p> </li> <li> <p>Go automatically breaks after the matched case. No explicit <code>break</code> is needed.</p> </li> <li>Switch cases do not have to be constants, and values do not need to be integers.</li> </ul>"},{"location":"controlflowstatements/#example_6","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n)\n\nfunc main() {\n    fmt.Print(\"Go runs on \")\n    switch os := runtime.GOOS; os {\n    case \"darwin\":\n        fmt.Println(\"macOS.\")\n    case \"linux\":\n        fmt.Println(\"Linux.\")\n    default:\n        // freebsd, openbsd, plan9, windows...\n        fmt.Printf(\"%s.\\n\", os)\n    }\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_5","title":"Explanation","text":"<ol> <li><code>os := runtime.GOOS</code> initializes a variable with the operating system name.</li> <li> <p>The <code>switch</code> evaluates <code>os</code> and executes only the first matching case:</p> </li> <li> <p><code>\"darwin\"</code> \u2192 prints <code>\"macOS.\"</code></p> </li> <li><code>\"linux\"</code> \u2192 prints <code>\"Linux.\"</code></li> <li><code>default</code> \u2192 prints any other OS.</li> <li>No <code>break</code> statements are required \u2014 Go stops automatically after executing the matching case.</li> </ol>"},{"location":"controlflowstatements/#output-example-on-linux","title":"Output (Example on Linux)","text":"<pre><code>Go runs on Linux.\n</code></pre>"},{"location":"controlflowstatements/#key-points_2","title":"Key Points","text":"<ul> <li> <p>Go\u2019s <code>switch</code> is more flexible than many other languages:</p> </li> <li> <p>Cases can be any expression, not just constants.</p> </li> <li>Only the matching case executes; no fallthrough unless explicitly requested with the <code>fallthrough</code> keyword.</li> <li>Variables declared in the switch statement (like <code>os</code> above) are scoped only within the switch.</li> </ul>"},{"location":"controlflowstatements/#switch-evaluation-order","title":"Switch Evaluation Order","text":"<p>In Go, switch cases are evaluated from top to bottom. The switch stops at the first case that succeeds \u2014 later cases are not evaluated.</p> <p>Example:</p> <p><code>go switch i { case 0: case f(): }</code></p> <p>If <code>i == 0</code>, the function <code>f()</code> is not called, because the first case matched.</p>"},{"location":"controlflowstatements/#example-checking-days-until-saturday","title":"Example: Checking Days Until Saturday","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    fmt.Println(\"When's Saturday?\")\n    today := time.Now().Weekday()\n    switch time.Saturday {\n    case today + 0:\n        fmt.Println(\"Today.\")\n    case today + 1:\n        fmt.Println(\"Tomorrow.\")\n    case today + 2:\n        fmt.Println(\"In two days.\")\n    default:\n        fmt.Println(\"Too far away.\")\n    }\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_6","title":"Explanation","text":"<ol> <li><code>today := time.Now().Weekday()</code> gets the current day of the week.</li> <li> <p>The <code>switch</code> statement checks <code>time.Saturday</code> against relative values:</p> </li> <li> <p><code>today + 0</code> \u2192 today</p> </li> <li><code>today + 1</code> \u2192 tomorrow</li> <li><code>today + 2</code> \u2192 in two days</li> <li>The first case that matches executes, and the switch exits immediately.</li> <li>The <code>default</code> case runs if none of the other cases match.</li> </ol>"},{"location":"controlflowstatements/#output-example","title":"Output (Example)","text":"<pre><code>When's Saturday?\nTomorrow.\n</code></pre> <p>Note: In the Go Playground, <code>time.Now()</code> starts at <code>2009-11-10 23:00:00 UTC</code>.</p>"},{"location":"controlflowstatements/#key-points_3","title":"Key Points","text":"<ul> <li>Go evaluates cases sequentially from top to bottom.</li> <li>Only the first successful case executes.</li> <li>This allows you to include complex expressions in later cases without worrying about unnecessary evaluation.</li> </ul>"},{"location":"controlflowstatements/#switch-with-no-condition","title":"Switch with No Condition","text":"<p>A switch without a condition in Go is equivalent to <code>switch true</code>. This allows you to write clean, readable if-then-else chains without nesting multiple <code>if</code> statements.</p>"},{"location":"controlflowstatements/#example_7","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    t := time.Now()\n    switch {\n    case t.Hour() &lt; 12:\n        fmt.Println(\"Good morning!\")\n    case t.Hour() &lt; 17:\n        fmt.Println(\"Good afternoon.\")\n    default:\n        fmt.Println(\"Good evening.\")\n    }\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_7","title":"Explanation","text":"<ol> <li><code>switch { ... }</code> without a condition automatically evaluates each case as a boolean expression.</li> <li>The first case that evaluates to <code>true</code> is executed.</li> <li>The <code>default</code> case runs if no other case matches.</li> </ol> <p>This pattern is ideal for multiple conditional branches where only one branch should run.</p>"},{"location":"controlflowstatements/#output-example_1","title":"Output (Example)","text":"<pre><code>Good afternoon.\n</code></pre> <p>Output will vary depending on the current system time.</p>"},{"location":"controlflowstatements/#key-points_4","title":"Key Points","text":"<ul> <li><code>switch</code> without a condition behaves like <code>switch true</code>.</li> <li>Each <code>case</code> is a boolean expression.</li> <li>Only the first true case executes.</li> <li>It improves readability over long chains of <code>if-else if-else</code> statements.</li> </ul>"},{"location":"controlflowstatements/#defer-statement","title":"Defer Statement","text":"<p>In Go, the <code>defer</code> statement postpones the execution of a function until the surrounding function returns.</p> <ul> <li>The arguments of the deferred function are evaluated immediately.</li> <li>The function call itself is executed later, just before the function exits.</li> </ul> <p>This is often used for cleanup tasks, such as closing files or releasing resources.</p>"},{"location":"controlflowstatements/#example_8","title":"Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    defer fmt.Println(\"world\")\n\n    fmt.Println(\"hello\")\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_8","title":"Explanation","text":"<ol> <li><code>defer fmt.Println(\"world\")</code> schedules the <code>Println</code> call to run after <code>main</code> returns.</li> <li><code>fmt.Println(\"hello\")</code> runs immediately.</li> <li>When <code>main</code> is about to exit, the deferred call executes, printing <code>\"world\"</code>.</li> </ol>"},{"location":"controlflowstatements/#output_5","title":"Output","text":"<pre><code>hello\nworld\n</code></pre>"},{"location":"controlflowstatements/#key-points_5","title":"Key Points","text":"<ul> <li>Multiple <code>defer</code> statements are executed in LIFO order (last-in, first-out).</li> <li>Useful for resource cleanup:</li> </ul> <pre><code>f, _ := os.Open(\"file.txt\")\ndefer f.Close() // ensures file is closed at the end of the function\n</code></pre> <ul> <li>Arguments are evaluated at the point of defer, but the call happens later.</li> </ul>"},{"location":"controlflowstatements/#stacking-defers","title":"Stacking Defers","text":"<p>In Go, deferred function calls are pushed onto a stack. When the surrounding function returns, the deferred calls are executed in last-in, first-out (LIFO) order.</p> <p>This allows you to schedule multiple cleanup or logging tasks and ensures they run in reverse order of their deferral.</p>"},{"location":"controlflowstatements/#example_9","title":"Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"counting\")\n\n    for i := 0; i &lt; 10; i++ {\n        defer fmt.Println(i)\n    }\n\n    fmt.Println(\"done\")\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_9","title":"Explanation","text":"<ol> <li><code>fmt.Println(\"counting\")</code> prints immediately.</li> <li>The <code>for</code> loop defers printing numbers <code>0</code> to <code>9</code>. Each deferred call is pushed onto the stack.</li> <li><code>fmt.Println(\"done\")</code> prints next.</li> <li>When <code>main</code> returns, deferred calls execute in reverse order, printing <code>9</code> down to <code>0</code>.</li> </ol>"},{"location":"controlflowstatements/#output_6","title":"Output","text":"<pre><code>counting\ndone\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n</code></pre>"},{"location":"controlflowstatements/#key-points_6","title":"Key Points","text":"<ul> <li>Deferred calls are executed after the surrounding function finishes.</li> <li>They run in LIFO order, so the last deferred function executes first.</li> <li> <p>Useful for:</p> </li> <li> <p>Reversing operations</p> </li> <li>Cleaning up resources in reverse order of acquisition</li> </ul> <p>\u2705 You have completed the Defer lesson! You can now move on to the next lesson or explore other Go topics.</p>"},{"location":"controlflowstatements/#if-and-else","title":"If and Else","text":"<p>In Go, variables declared inside an <code>if</code> short statement are also available inside any associated <code>else</code> block. However, these variables are scoped only within the <code>if</code> and <code>else</code> statements \u2014 they cannot be accessed outside.</p>"},{"location":"controlflowstatements/#example_10","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc pow(x, n, lim float64) float64 {\n    if v := math.Pow(x, n); v &lt; lim {\n        return v\n    } else {\n        fmt.Printf(\"%g &gt;= %g\\n\", v, lim)\n    }\n    // can't use v here, though\n    return lim\n}\n\nfunc main() {\n    fmt.Println(\n        pow(3, 2, 10),\n        pow(3, 3, 20),\n    )\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_10","title":"Explanation","text":"<ol> <li>The variable <code>v</code> is declared inside the <code>if</code> statement:</li> </ol> <p><code>go    if v := math.Pow(x, n); v &lt; lim {</code></p> <p>It exists only within the <code>if</code> and <code>else</code> blocks.</p> <ol> <li> <p>If <code>v</code> is less than <code>lim</code>, the function returns <code>v</code>.    Otherwise, the <code>else</code> block runs and prints a message.</p> </li> <li> <p>After the <code>if-else</code>, <code>v</code> is out of scope \u2014 trying to use it there would cause a compiler error.</p> </li> </ol>"},{"location":"controlflowstatements/#output_7","title":"Output","text":"<pre><code>27 &gt;= 20\n9 20\n</code></pre>"},{"location":"controlflowstatements/#key-points_7","title":"Key Points","text":"<ul> <li>Variables declared in the <code>if</code> short statement (<code>if v := ...; condition</code>)   are available only within that <code>if</code> and its corresponding <code>else</code>.</li> <li>The <code>else</code> block runs only if the <code>if</code> condition evaluates to <code>false</code>.</li> <li>This makes Go\u2019s <code>if</code> syntax concise and allows safe, scoped variable declarations.</li> </ul> <p>\u2705 Summary: Go\u2019s <code>if</code> and <code>else</code> statements can include short variable declarations, which remain local to those blocks \u2014 clean and efficient for conditional logic.</p>"},{"location":"controlflowstatements/#switch-statement_1","title":"Switch Statement","text":"<p>A <code>switch</code> statement in Go provides a concise way to handle multiple conditional branches. It\u2019s often cleaner and more readable than writing multiple <code>if\u2013else</code> chains.</p>"},{"location":"controlflowstatements/#how-it-works_1","title":"How It Works","text":"<ul> <li>A <code>switch</code> runs the first case that matches the condition.</li> <li>Unlike C, C++, or Java, Go does not require a <code>break</code> statement \u2014 it stops automatically after a matching case.</li> <li>Cases don\u2019t have to be constants or integers \u2014 they can be strings, variables, or expressions.</li> </ul>"},{"location":"controlflowstatements/#example_11","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n)\n\nfunc main() {\n    fmt.Print(\"Go runs on \")\n    switch os := runtime.GOOS; os {\n    case \"darwin\":\n        fmt.Println(\"macOS.\")\n    case \"linux\":\n        fmt.Println(\"Linux.\")\n    default:\n        // freebsd, openbsd, plan9, windows...\n        fmt.Printf(\"%s.\\n\", os)\n    }\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_11","title":"Explanation","text":"<ol> <li> <p>The short statement <code>os := runtime.GOOS</code> assigns the operating system name.    It\u2019s scoped only within the <code>switch</code>.</p> </li> <li> <p>Go compares <code>os</code> against each <code>case</code>:</p> </li> <li> <p><code>\"darwin\"</code> \u2192 macOS</p> </li> <li><code>\"linux\"</code> \u2192 Linux</li> <li> <p><code>default</code> \u2192 all other OS names</p> </li> <li> <p>The first matching case runs, and Go automatically breaks afterward.</p> </li> </ol>"},{"location":"controlflowstatements/#possible-outputs","title":"Possible Outputs","text":"<p>Depending on your system:</p> <pre><code>Go runs on Linux.\n</code></pre> <p>or</p> <pre><code>Go runs on macOS.\n</code></pre> <p>or</p> <pre><code>Go runs on windows.\n</code></pre>"},{"location":"controlflowstatements/#key-points_8","title":"Key Points","text":"<ul> <li>No need for manual <code>break</code> \u2014 it\u2019s implicit.</li> <li>Cases can evaluate any type of expression.</li> <li>Short variable declarations (like <code>os := ...</code>) are scoped to the <code>switch</code> only.</li> <li><code>default</code> handles all unmatched cases, similar to the final <code>else</code>.</li> </ul> <p>\u2705 Tip: Use <code>switch</code> when checking one value against several possibilities \u2014 it makes code cleaner and easier to read than long <code>if-else</code> chains.</p>"},{"location":"controlflowstatements/#switch-evaluation-order-in-go","title":"\ud83c\udf00 Switch Evaluation Order in Go","text":"<p>In Go, switch cases are checked from top to bottom, and evaluation stops immediately when a matching case is found \u2014 no further cases are evaluated.</p>"},{"location":"controlflowstatements/#example-code","title":"Example Code","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    fmt.Println(\"When's Saturday?\")\n\n    today := time.Now().Weekday()\n\n    switch time.Saturday {\n    case today + 0:\n        fmt.Println(\"Today.\")\n    case today + 1:\n        fmt.Println(\"Tomorrow.\")\n    case today + 2:\n        fmt.Println(\"In two days.\")\n    default:\n        fmt.Println(\"Too far away.\")\n    }\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_12","title":"Explanation","text":"<ol> <li> <p><code>today := time.Now().Weekday()</code>    \u2192 gets the current day of the week (like <code>Monday</code>, <code>Tuesday</code>, etc.).</p> </li> <li> <p>The <code>switch</code> compares <code>time.Saturday</code> to each case in order:</p> </li> <li> <p><code>today + 0</code> \u2192 means today is Saturday.</p> </li> <li><code>today + 1</code> \u2192 means Saturday is tomorrow.</li> <li><code>today + 2</code> \u2192 means Saturday is in two days.</li> <li> <p>Otherwise \u2192 <code>\"Too far away.\"</code></p> </li> <li> <p>Go stops evaluating after the first matching case \u2014 it does not check further.</p> </li> </ol>"},{"location":"controlflowstatements/#example-outputs","title":"Example Outputs","text":"<p>If today is Friday:</p> <pre><code>When's Saturday?\nTomorrow.\n</code></pre> <p>If today is Saturday:</p> <pre><code>When's Saturday?\nToday.\n</code></pre> <p>If today is Tuesday:</p> <pre><code>When's Saturday?\nToo far away.\n</code></pre>"},{"location":"controlflowstatements/#key-concepts","title":"\u2699\ufe0f Key Concepts","text":"<ul> <li>Switches evaluate top to bottom.</li> <li>Go stops after the first successful match (no \u201cfallthrough\u201d unless explicitly stated).</li> <li>Each <code>case</code> can be an expression, not just a constant.</li> <li>The <code>default</code> clause runs if no other case matches.</li> </ul> <p>\ud83d\udca1 Trivia: In the Go Playground, <code>time.Now()</code> is always <code>2009-11-10 23:00:00 UTC</code> \u2014 it\u2019s a fixed date for deterministic program output. So in that environment, the day is Tuesday, making the output always:</p> <pre><code>When's Saturday?\nToo far away.\n</code></pre>"},{"location":"controlflowstatements/#switch-with-no-condition-in-go","title":"\ud83c\udf07 Switch with No Condition in Go","text":"<p>A switch without a condition in Go is equivalent to writing:</p> <pre><code>switch true {\n</code></pre> <p>This allows each <code>case</code> to act as a boolean expression \u2014 similar to a clean, readable <code>if-else if-else</code> chain.</p>"},{"location":"controlflowstatements/#example-code_1","title":"Example Code","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    t := time.Now()\n\n    switch {\n    case t.Hour() &lt; 12:\n        fmt.Println(\"Good morning!\")\n    case t.Hour() &lt; 17:\n        fmt.Println(\"Good afternoon.\")\n    default:\n        fmt.Println(\"Good evening.\")\n    }\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_13","title":"Explanation","text":"<ol> <li> <p><code>t := time.Now()</code>    \u2192 captures the current system time.</p> </li> <li> <p>The <code>switch</code> has no condition, so Go automatically treats it as <code>switch true</code>.</p> </li> <li> <p>Each <code>case</code> is evaluated in order:</p> </li> <li> <p>If <code>t.Hour() &lt; 12</code>, prints <code>\"Good morning!\"</code></p> </li> <li>Else if <code>t.Hour() &lt; 17</code>, prints <code>\"Good afternoon.\"</code></li> <li> <p>Otherwise, <code>\"Good evening.\"</code></p> </li> <li> <p>Once a matching case is found, Go exits the switch \u2014 no further cases are checked.</p> </li> </ol>"},{"location":"controlflowstatements/#example-outputs_1","title":"Example Outputs","text":"<p>If the current time is:</p> Time (24h) Output 09:45 Good morning! 14:30 Good afternoon. 20:10 Good evening."},{"location":"controlflowstatements/#key-points_9","title":"\u2699\ufe0f Key Points","text":"<ul> <li><code>switch</code> without a condition is shorthand for <code>switch true</code>.</li> <li>Makes long <code>if-else</code> chains more compact and readable.</li> <li>Each case should be a boolean expression.</li> <li>Execution stops after the first true case.</li> </ul> <p>\ud83d\udca1 Tip: You can use this style for multiple complex conditions \u2014 it keeps your Go code simple, expressive, and elegant.</p>"},{"location":"controlflowstatements/#defer-in-go","title":"\ud83d\udd52 Defer in Go","text":"<p>A <code>defer</code> statement postpones the execution of a function until the surrounding function returns.</p> <p>When you call <code>defer</code>, the arguments are evaluated immediately, but the function call itself is executed later \u2014 right before the function exits.</p>"},{"location":"controlflowstatements/#example-code_2","title":"Example Code","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    defer fmt.Println(\"world\")\n\n    fmt.Println(\"hello\")\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_14","title":"Explanation","text":"<ol> <li> <p><code>defer fmt.Println(\"world\")</code>    \u2192 schedules <code>\"world\"</code> to be printed after <code>main()</code> finishes.</p> </li> <li> <p><code>fmt.Println(\"hello\")</code>    \u2192 executes immediately and prints <code>\"hello\"</code>.</p> </li> <li> <p>Once <code>main()</code> is about to exit, Go executes the deferred statement, printing <code>\"world\"</code>.</p> </li> </ol>"},{"location":"controlflowstatements/#output_8","title":"Output","text":"<pre><code>hello\nworld\n</code></pre>"},{"location":"controlflowstatements/#key-points_10","title":"\u2699\ufe0f Key Points","text":"<ul> <li><code>defer</code> is executed after the surrounding function ends.</li> <li>Arguments are evaluated immediately when the <code>defer</code> is declared.</li> <li> <p>Useful for tasks like:</p> </li> <li> <p>Closing files (<code>defer file.Close()</code>)</p> </li> <li>Unlocking mutexes</li> <li>Releasing network connections or database resources</li> </ul> <p>\ud83d\udca1 Tip: Think of <code>defer</code> as a \u201ccleanup-on-exit\u201d mechanism \u2014 perfect for writing cleaner, safer Go code.</p>"},{"location":"controlflowstatements/#stacking-defer-in-go","title":"\ud83d\udd01 Stacking <code>defer</code> in Go","text":"<p>In Go, deferred function calls are pushed onto a stack. When the surrounding function (<code>main</code>, in this case) returns, deferred calls are executed in last-in-first-out (LIFO) order \u2014 like popping items from a stack.</p>"},{"location":"controlflowstatements/#example-code_3","title":"Example Code","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"counting\")\n\n    for i := 0; i &lt; 10; i++ {\n        defer fmt.Println(i)\n    }\n\n    fmt.Println(\"done\")\n}\n</code></pre>"},{"location":"controlflowstatements/#explanation_15","title":"Explanation","text":"<ol> <li>The loop runs from <code>i = 0</code> to <code>i = 9</code>.    Each time, it defers <code>fmt.Println(i)</code> \u2014 adding it to the stack.</li> <li>When the loop finishes, all 10 deferred calls are stacked.</li> <li> <p>As <code>main()</code> returns:</p> </li> <li> <p>Go pops and executes each deferred call in reverse order.</p> </li> </ol>"},{"location":"controlflowstatements/#execution-order","title":"Execution Order","text":"Step Action Output 1 Print <code>\"counting\"</code> counting 2 Loop defers 10 print calls (nothing yet) 3 Print <code>\"done\"</code> done 4 Execute defers (LIFO) 9 \u2192 0"},{"location":"controlflowstatements/#final-output","title":"Final Output","text":"<pre><code>counting\ndone\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n</code></pre>"},{"location":"controlflowstatements/#key-takeaways","title":"\ud83e\udde0 Key Takeaways","text":"<ul> <li>Deferred calls execute after the function finishes.</li> <li>LIFO order: last deferred \u2192 executed first.</li> <li>Commonly used for cleanup in reverse order, like:</li> </ul> <p><code>go   defer conn.Close()   defer file.Close()</code></p> <p>\ud83d\udca1 Analogy: Think of <code>defer</code> as \u201cstacking up cleanup tasks\u201d \u2014 when you leave the room (function), you clean up everything you stacked, in reverse order.</p>"},{"location":"debugging/","title":"Index","text":""},{"location":"debugging/#1-install-delve","title":"1. Install Delve","text":"<pre><code>go install github.com/go-delve/delve/cmd/dlv@latest\n</code></pre> <ul> <li>Make sure your <code>$GOPATH/bin</code> or <code>$HOME/go/bin</code> is in your PATH.</li> <li>Check installation:</li> </ul> <pre><code>dlv version\n</code></pre>"},{"location":"debugging/#2-start-a-debug-session","title":"2. Start a debug session","text":"<p>Assume you have a Go program <code>main.go</code>:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc Add(x, y int) int {\n    return x + y\n}\n\nfunc main() {\n    sum := Add(10, 15)\n    fmt.Println(\"Sum:\", sum)\n}\n</code></pre>"},{"location":"debugging/#start-debugging","title":"Start debugging","text":"<pre><code>dlv debug\n</code></pre> <ul> <li>This compiles your program with debugging info and starts an interactive session.</li> </ul>"},{"location":"debugging/#3-basic-dlv-commands","title":"3. Basic <code>dlv</code> commands","text":""},{"location":"debugging/#31-breakpoints","title":"3.1 Breakpoints","text":"<p>Set a breakpoint at a line:</p> <pre><code>(dlv) break main.go:6\n</code></pre> <ul> <li>Or at a function:</li> </ul> <pre><code>(dlv) break main.Add\n</code></pre>"},{"location":"debugging/#32-run-the-program","title":"3.2 Run the program","text":"<pre><code>(dlv) continue\n</code></pre> <ul> <li>Runs until it hits a breakpoint.</li> </ul>"},{"location":"debugging/#33-inspect-variables","title":"3.3 Inspect variables","text":"<p>When stopped at a breakpoint:</p> <pre><code>(dlv) print x\n(dlv) print y\n(dlv) print sum\n</code></pre> <ul> <li>You can also evaluate expressions:</li> </ul> <pre><code>(dlv) print x + y\n</code></pre>"},{"location":"debugging/#34-step-through-code","title":"3.4 Step through code","text":"<ul> <li>Step into functions:</li> </ul> <pre><code>(dlv) step\n</code></pre> <ul> <li>Step over current line:</li> </ul> <pre><code>(dlv) next\n</code></pre> <ul> <li>Step out of the current function:</li> </ul> <pre><code>(dlv) stepout\n</code></pre>"},{"location":"debugging/#35-list-code-around-current-line","title":"3.5 List code around current line","text":"<pre><code>(dlv) list\n</code></pre>"},{"location":"debugging/#36-watch-variables","title":"3.6 Watch variables","text":"<pre><code>(dlv) watch sum\n</code></pre> <ul> <li>Stops execution when <code>sum</code> changes.</li> </ul>"},{"location":"debugging/#37-backtrace","title":"3.7 Backtrace","text":"<p>Show the call stack:</p> <pre><code>(dlv) bt\n</code></pre>"},{"location":"debugging/#4-exit-debug-session","title":"4. Exit debug session","text":"<pre><code>(dlv) quit\n</code></pre>"},{"location":"debugging/#5-debugging-tests","title":"5. Debugging tests","text":"<p>You can also debug tests:</p> <pre><code>dlv test\n</code></pre> <ul> <li>Or debug a specific test:</li> </ul> <pre><code>dlv test -- -test.run TestAdd\n</code></pre> <ul> <li>Use the same commands (<code>break</code>, <code>print</code>, <code>next</code>, etc.) inside your test.</li> </ul>"},{"location":"debugging/#6-tips-best-practices","title":"6. Tips &amp; best practices","text":"<ol> <li>Use breakpoints on functions rather than line numbers when refactoring often.</li> <li>Inspect complex types: slices, structs, maps using <code>print</code>.</li> <li>Step over vs step into: <code>next</code> skips function internals; <code>step</code> enters.</li> <li>Combine with VS Code or GoLand for GUI debugging; Delve works behind the scenes.</li> </ol>"},{"location":"debugging/#example-session","title":"Example session:","text":"<pre><code>$ dlv debug\n(dlv) break main.Add\n(dlv) continue\n(dlv) print x\n(dlv) next\n(dlv) step\n(dlv) print sum\n(dlv) continue\n(dlv) quit\n</code></pre>"},{"location":"debugging/#references","title":"References","text":"<ul> <li>Delve is a debugger for the Go programming language.</li> </ul>"},{"location":"gotests/","title":"GO TESTS ROADMAP","text":""},{"location":"gotests/#style-identical-to-learn-go-with-tests","title":"Style: identical to Learn Go With Tests","text":""},{"location":"gotests/#coverage-all-topics-you-learned","title":"Coverage: all topics you learned","text":""},{"location":"gotests/#structure-multi-folder","title":"Structure: multi-folder","text":""},{"location":"gotests/#difficulty-basic-but-real","title":"Difficulty: basic (but real)","text":""},{"location":"gotests/#1-project-folder-structure","title":"1. Project Folder Structure","text":"<p>Create this structure:</p> <pre><code>go-basics-tests/\n    functions/\n        add.go\n        add_test.go\n    variables/\n        convert.go\n        convert_test.go\n    flow/\n        loops.go\n        loops_test.go\n    slices/\n        slice_ops.go\n        slice_ops_test.go\n    maps/\n        map_ops.go\n        map_ops_test.go\n    structs/\n        user.go\n        user_test.go\n    pointers/\n        counter.go\n        counter_test.go\n    closures/\n        gen.go\n        gen_test.go\n</code></pre> <p>Each folder covers a topic.</p>"},{"location":"gotests/#2-what-to-test-guided-checklist","title":"2. What to Test (Guided Checklist)","text":"<p>Below are the required tests, but written as specifications. You will implement them yourself.</p>"},{"location":"gotests/#functions","title":"functions/","text":""},{"location":"gotests/#test-1-add-two-integers","title":"Test 1: Add two integers","text":"<ul> <li>Write a function <code>Add(a, b int) int</code></li> <li> <p>Test cases:</p> </li> <li> <p>positive numbers</p> </li> <li>negative numbers</li> <li>zero</li> </ul>"},{"location":"gotests/#test-2-repeat-a-string-n-times","title":"Test 2: Repeat a string N times","text":"<ul> <li>Function: <code>Repeat(s string, n int) string</code></li> <li>Table-driven test.</li> </ul>"},{"location":"gotests/#variables","title":"variables/","text":""},{"location":"gotests/#test-1-celsius-to-fahrenheit-conversion","title":"Test 1: Celsius to Fahrenheit conversion","text":"<ul> <li>Function: <code>CtoF(c float64) float64</code></li> <li> <p>Test:</p> </li> <li> <p>known input/output pairs.</p> </li> </ul>"},{"location":"gotests/#test-2-boolean-toggler","title":"Test 2: Boolean toggler","text":"<ul> <li>Function: <code>Toggle(b bool) bool</code></li> <li>Write two test cases.</li> </ul>"},{"location":"gotests/#flow","title":"flow/","text":""},{"location":"gotests/#test-1-sum-numbers-1-to-n","title":"Test 1: Sum numbers 1 to N","text":"<ul> <li>Function: <code>SumTo(n int) int</code></li> <li> <p>Test:</p> </li> <li> <p>1</p> </li> <li>5</li> <li>10</li> </ul>"},{"location":"gotests/#test-2-find-the-first-even-number-in-a-slice","title":"Test 2: Find the first even number in a slice","text":"<ul> <li>Function: <code>FirstEven([]int) (int, bool)</code></li> <li> <p>Test:</p> </li> <li> <p>slice with evens</p> </li> <li>slice with no evens</li> </ul>"},{"location":"gotests/#slices","title":"slices/","text":""},{"location":"gotests/#test-1-appendsafe","title":"Test 1: AppendSafe","text":"<ul> <li>Function: <code>AppendSafe(s []int, v int) []int</code></li> <li> <p>Behavior:</p> </li> <li> <p>original slice must not mutate</p> </li> <li>new slice contains old values + v</li> </ul> <p>Test:</p> <ul> <li>original and returned slice should differ.</li> </ul>"},{"location":"gotests/#test-2-sumslice","title":"Test 2: SumSlice","text":"<ul> <li>Function: <code>SumSlice([]int) int</code></li> <li>Table test.</li> </ul>"},{"location":"gotests/#maps","title":"maps/","text":""},{"location":"gotests/#test-1-basic-map-get","title":"Test 1: Basic map get","text":"<ul> <li>Function: <code>GetAge(m map[string]int, name string) (int, bool)</code></li> <li> <p>Test for:</p> </li> <li> <p>existing key</p> </li> <li>missing key</li> </ul>"},{"location":"gotests/#test-2-updatestock","title":"Test 2: UpdateStock","text":"<ul> <li>Function: <code>UpdateStock(m map[string]int, item string, qty int)</code></li> <li> <p>Test:</p> </li> <li> <p>increasing quantity</p> </li> <li>creating new key</li> <li>overwriting existing</li> </ul>"},{"location":"gotests/#structs","title":"structs/","text":""},{"location":"gotests/#define","title":"Define:","text":"<pre><code>type Book struct {\n    Title  string\n    Author string\n    Price  float64\n}\n</code></pre>"},{"location":"gotests/#test-1-discountpriceb-book-percent-float64-float64","title":"Test 1: DiscountPrice(b Book, percent float64) float64","text":"<ul> <li> <p>Test:</p> </li> <li> <p>10% discount</p> </li> <li>0% discount</li> <li>100% discount</li> </ul>"},{"location":"gotests/#test-2-renameauthorb-book-newauthor-string","title":"Test 2: RenameAuthor(b *Book, newAuthor string)","text":"<ul> <li> <p>Test:</p> </li> <li> <p>uses pointer (value should change)</p> </li> </ul>"},{"location":"gotests/#pointers","title":"pointers/","text":""},{"location":"gotests/#define-struct-counter-with-field-n-int","title":"Define struct Counter with field <code>n int</code>","text":""},{"location":"gotests/#test-1-increment","title":"Test 1: Increment","text":"<ul> <li>Method: <code>func (c *Counter) Inc()</code></li> <li> <p>Test:</p> </li> <li> <p>call Inc twice \u2192 value is 2</p> </li> <li>pointer receiver required</li> </ul>"},{"location":"gotests/#test-2-reset","title":"Test 2: Reset","text":"<ul> <li>Method: <code>func (c *Counter) Reset()</code></li> <li> <p>Test:</p> </li> <li> <p>sets counter to 0</p> </li> </ul>"},{"location":"gotests/#closures","title":"closures/","text":""},{"location":"gotests/#test-1-newidgenerator","title":"Test 1: NewIDGenerator","text":"<p>Function returns a closure:</p> <pre><code>func NewIDGen() func() int\n</code></pre> <p>Every call increases the ID.</p> <p>Test:</p> <ul> <li>call 3 times \u2192 1,2,3</li> </ul>"},{"location":"gotests/#test-2-adder","title":"Test 2: Adder","text":"<ul> <li>Function: <code>NewAdder(start int) func(int) int</code></li> <li> <p>Test:</p> </li> <li> <p>closure maintains internal state.</p> </li> </ul>"},{"location":"gotests/#3-rules-important","title":"3. Rules (important)","text":"<ol> <li> <p>Use Learn Go With Tests style:</p> </li> <li> <p><code>testing.T</code></p> </li> <li>subtests (<code>t.Run</code>)</li> <li>table-driven tests</li> <li> <p>helper functions (if needed)</p> </li> <li> <p>Create implementation only after test fails.</p> </li> <li> <p>Run tests all the time:</p> </li> </ol> <p><code>go test ./...</code></p> <ol> <li>Don\u2019t copy online answers.    Make mistakes. Fix them. That\u2019s how you become badass.</li> </ol>"},{"location":"gotests/notes/","title":"Notes","text":""},{"location":"gotests/notes/#1-test-naming-pattern","title":"1. Test Naming Pattern","text":"<ul> <li>All test functions start with <code>Test\u2026</code> \u2192 <code>TestAdd</code>, <code>TestHello</code>.</li> <li>Test files always end with <code>_test.go</code>.</li> </ul> <p>Pattern to notice: Go automatically detects <code>Test*</code> functions. This is consistent across all packages.</p>"},{"location":"gotests/notes/#2-assertion-pattern","title":"2. Assertion Pattern","text":"<ul> <li>Store output in <code>got</code>.</li> <li>Define expected output as <code>want</code>.</li> <li>Compare: <code>if got != want { t.Errorf(...) }</code>.</li> </ul> <p>Pattern:</p> <pre><code>got := Function(input)\nwant := expected\nif got != want {\n    t.Errorf(\"got %v want %v\", got, want)\n}\n</code></pre> <p>Everything you test in Go follows this basic template, whether it\u2019s strings, ints, slices, or structs.</p>"},{"location":"gotests/notes/#3-helper-pattern","title":"3. Helper Pattern","text":"<ul> <li>If checks are repeated, extract to helper function:</li> </ul> <pre><code>func assertEqual(t testing.TB, got, want int) {\n    t.Helper()\n    if got != want {\n        t.Errorf(\"got %d want %d\", got, want)\n    }\n}\n</code></pre> <ul> <li>Use <code>t.Helper()</code> so the test reports the call site instead of the helper.</li> </ul>"},{"location":"gotests/notes/#4-subtest-pattern","title":"4. Subtest Pattern","text":"<ul> <li>For multiple scenarios:</li> </ul> <pre><code>t.Run(\"description\", func(t *testing.T) {\n    got := Function(input)\n    want := expected\n    if got != want {\n        t.Errorf(\"got %v want %v\", got, want)\n    }\n})\n</code></pre> <ul> <li>You\u2019ll see this pattern a lot when testing multiple inputs.</li> </ul>"},{"location":"gotests/notes/#5-common-types-verbs","title":"5. Common types &amp; verbs","text":"<ul> <li><code>%d</code> \u2192 integers</li> <li><code>%q</code> \u2192 strings (quotes)</li> <li><code>%v</code> \u2192 any type (generic, structs, slices)</li> </ul> <p>Pattern: Always match type with the correct verb for readability.</p>"},{"location":"gotests/notes/#6-tdd-cycle-pattern","title":"6. TDD Cycle Pattern","text":"<ol> <li>Write a failing test.</li> <li>Make it compile.</li> <li>Write minimum code to pass.</li> <li>Refactor safely with tests.</li> </ol> <p>This cycle is the same pattern for any feature you develop in Go.</p>"},{"location":"interviews/","title":"Index","text":""},{"location":"interviews/#references","title":"References","text":"<ul> <li>50 Popular Golang Interview Questions (+ Quiz!)</li> <li>Golang interview questions and answers in 2025</li> <li>Golang forum bridge</li> </ul>"},{"location":"methodsandinterfaces/methodsandinterfaces/","title":"1. What are Methods in Go?","text":"<p>In Go, a method is a function with a receiver. The receiver can be:</p> <ul> <li>Value receiver: method works on a copy of the struct</li> <li>Pointer receiver: method works on the original struct</li> </ul> <p>Syntax:</p> <pre><code>func (receiver Type) MethodName(params) returnType {\n    // code\n}\n</code></pre> <ul> <li><code>receiver</code> is usually a variable representing the struct instance.</li> <li><code>Type</code> is the struct type (or any custom type).</li> </ul>"},{"location":"methodsandinterfaces/methodsandinterfaces/#example-basic-method","title":"Example \u2014 Basic Method","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype User struct {\n    Name string\n    Age  int\n}\n\n// Value receiver\nfunc (u User) Greet() string {\n    return \"Hello, \" + u.Name\n}\n\n// Pointer receiver\nfunc (u *User) HaveBirthday() {\n    u.Age += 1\n}\n\nfunc main() {\n    user := User{Name: \"Alice\", Age: 25}\n\n    fmt.Println(user.Greet()) // Hello, Alice\n\n    user.HaveBirthday()\n    fmt.Println(user.Age)     // 26\n}\n</code></pre> <p>Key points:</p> <ul> <li>Value receiver: <code>Greet()</code> does not modify <code>user</code></li> <li>Pointer receiver: <code>HaveBirthday()</code> modifies the original struct</li> </ul>"},{"location":"methodsandinterfaces/methodsandinterfaces/#2-real-world-uses-of-methods","title":"2. Real-World Uses of Methods","text":"<p>Methods are extremely useful because they associate behavior with data. This is similar to OOP, but Go keeps it simple.</p>"},{"location":"methodsandinterfaces/methodsandinterfaces/#examples-in-real-projects","title":"Examples in real projects:","text":"<ol> <li> <p>Backend / Business Logic</p> </li> <li> <p>User management: <code>user.ResetPassword()</code>, <code>user.IsActive()</code></p> </li> <li>Banking system: <code>account.Deposit()</code>, <code>account.Withdraw()</code></li> <li> <p>Inventory system: <code>product.IncreaseStock(amount)</code></p> </li> <li> <p>Encapsulation</p> </li> <li> <p>Struct fields can be private (<code>lowercase</code>) and methods control access:</p> <p>```go  type Account struct {      balance int  }</p> <p>func (a *Account) Deposit(amount int) {      if amount &gt; 0 {          a.balance += amount      }  }</p> <p>func (a *Account) Balance() int {      return a.balance  }  ```</p> </li> <li> <p>Stateful Closures</p> </li> <li> <p>Methods can return closures that capture struct state:</p> <p><code>go  func (a *Account) TransactionLogger() func(amount int) int {      return func(amount int) int {          a.balance += amount          return a.balance      }  }</code></p> </li> <li> <p>Collections of Methods</p> </li> <li> <p>Methods allow struct-based APIs in backend projects:</p> <ul> <li><code>Cart.AddItem()</code>, <code>Cart.RemoveItem()</code>, <code>Cart.Total()</code></li> <li>Makes code more readable and maintainable.</li> </ul> </li> </ol>"},{"location":"methodsandinterfaces/methodsandinterfaces/#3-importance-of-methods-in-backend-projects","title":"3. Importance of Methods in Backend Projects","text":"<ol> <li> <p>Organization of code</p> </li> <li> <p>Methods tie data + behavior together, reducing global state</p> </li> <li> <p>Easier to maintain and test</p> </li> <li> <p>Encapsulation and Safety</p> </li> <li> <p>Pointer receivers allow controlled mutation of structs</p> </li> <li> <p>Fields can remain private, exposed via methods only</p> </li> <li> <p>Reusability</p> </li> <li> <p>One method can be used across the backend wherever that struct is used</p> </li> <li> <p>Readability</p> </li> <li> <p>Instead of <code>UpdateUserAge(&amp;user, 25)</code>, you write <code>user.UpdateAge(25)</code> \u2014 more intuitive</p> </li> <li> <p>Testing</p> </li> <li> <p>Methods can be tested independently</p> </li> <li>You can combine methods with closures for stateful testing</li> </ol>"},{"location":"methodsandinterfaces/methodsandinterfaces/#4-disadvantages-things-to-watch-out-for","title":"4. Disadvantages / Things to Watch Out For","text":"<ol> <li> <p>Copying large structs</p> </li> <li> <p>Using value receivers on large structs copies the whole struct, which is inefficient</p> </li> <li> <p>Solution: use pointer receivers for large structs</p> </li> <li> <p>Mixing pointer and value receivers</p> </li> <li> <p>Can lead to confusion</p> </li> <li> <p>Rule of thumb: use pointer receiver if method modifies the struct or the struct is large; otherwise, value receiver is fine</p> </li> <li> <p>Interface complexity</p> </li> <li> <p>Too many small methods can lead to large interfaces</p> </li> <li> <p>Keep interfaces minimal (Go encourages small, composable interfaces)</p> </li> <li> <p>Concurrent access</p> </li> <li> <p>Methods do not automatically handle concurrency</p> </li> <li>If multiple goroutines call pointer-receiver methods that mutate the struct, you must use <code>sync.Mutex</code> or <code>sync.RWMutex</code></li> </ol>"},{"location":"methodsandinterfaces/methodsandinterfaces/#5-summary","title":"5. Summary","text":"Feature Value Receiver Pointer Receiver Modifies original struct No Yes Struct copying cost Copies entire struct No copy, uses pointer Use case Read-only methods Methods that mutate or large struct Safety in concurrency Same as pointer (must lock if needed) Same, must lock for safety <p>Backend importance:</p> <ul> <li>Methods are core to building maintainable, encapsulated, and testable business logic.</li> <li>They reduce global state and allow you to write reusable APIs.</li> </ul> <p>If you want, I can give a set of step-by-step method exercises that include:</p> <ul> <li>Value vs pointer receiver</li> <li>Methods returning closures</li> <li>Using methods in mini backend-style structs like <code>User</code>, <code>Account</code>, <code>Cart</code></li> </ul>"},{"location":"moretypes/","title":"More Types","text":""},{"location":"moretypes/#go-pointers","title":"Go Pointers","text":"<p>Go supports pointers, which hold the memory address of a value.</p> <ul> <li>The type <code>*T</code> represents a pointer to a value of type <code>T</code>.</li> <li>Its zero value is <code>nil</code>.</li> </ul> <pre><code>var p *int\n</code></pre>"},{"location":"moretypes/#getting-a-pointer","title":"Getting a Pointer","text":"<p>Use the <code>&amp;</code> operator to get the memory address of a variable.</p> <pre><code>i := 42\np = &amp;i\n</code></pre>"},{"location":"moretypes/#using-a-pointer","title":"Using a Pointer","text":"<p>The <code>*</code> operator dereferences a pointer \u2014 it accesses the value stored at that address.</p> <pre><code>fmt.Println(*p) // read i through pointer p\n*p = 21         // set i through pointer p\n</code></pre> <p>This is called dereferencing or indirection.</p> <p>Unlike C, Go does not allow pointer arithmetic.</p>"},{"location":"moretypes/#example","title":"Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    i, j := 42, 2701\n\n    p := &amp;i         // point to i\n    fmt.Println(*p) // read i through pointer\n    *p = 21         // set i through pointer\n    fmt.Println(i)  // new value of i\n\n    p = &amp;j          // point to j\n    *p = *p / 37    // modify j through pointer\n    fmt.Println(j)  // new value of j\n}\n</code></pre>"},{"location":"moretypes/#structs","title":"Structs","text":"<p>A struct is a collection of fields (data grouped together).</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n    X int\n    Y int\n}\n\nfunc main() {\n    fmt.Println(Vertex{1, 2})\n}\n</code></pre>"},{"location":"moretypes/#struct-fields","title":"Struct Fields","text":"<p>Access struct fields using the dot (.) operator.</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n    X int\n    Y int\n}\n\nfunc main() {\n    v := Vertex{1, 2}\n    v.X = 4\n    fmt.Println(v.X)\n}\n</code></pre>"},{"location":"moretypes/#pointers-to-structs","title":"Pointers to Structs","text":"<p>Struct fields can also be accessed via struct pointers.</p> <p>Instead of writing <code>(*p).X</code>, Go allows shorthand access using <code>p.X</code>.</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n    X int\n    Y int\n}\n\nfunc main() {\n    v := Vertex{1, 2}\n    p := &amp;v\n    p.X = 1e9\n    fmt.Println(v)\n}\n</code></pre>"},{"location":"moretypes/#struct-literals","title":"Struct Literals","text":"<p>A struct literal creates and initializes a struct.</p> <p>You can:</p> <ul> <li>Specify all fields in order.</li> <li>Specify only some fields by name (unordered).</li> <li>Use <code>&amp;</code> to get a pointer to the new struct.</li> </ul> <pre><code>package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n    X, Y int\n}\n\nvar (\n    v1 = Vertex{1, 2}  // type: Vertex\n    v2 = Vertex{X: 1}  // Y:0 is implicit\n    v3 = Vertex{}      // X:0, Y:0\n    p  = &amp;Vertex{1, 2} // type: *Vertex\n)\n\nfunc main() {\n    fmt.Println(v1, p, v2, v3)\n}\n</code></pre>"},{"location":"moretypes/#arrays","title":"Arrays","text":"<p>An array is a fixed-size sequence of elements of the same type.</p> <pre><code>var a [10]int\n</code></pre> <p>Here, <code>a</code> is an array of 10 integers.</p> <p>Array length is part of its type, so arrays cannot be resized \u2014 but Go provides slices for more flexible use.</p>"},{"location":"moretypes/#example_1","title":"Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var a [2]string\n    a[0] = \"Hello\"\n    a[1] = \"World\"\n\n    fmt.Println(a[0], a[1])\n    fmt.Println(a)\n\n    primes := [6]int{2, 3, 5, 7, 11, 13}\n    fmt.Println(primes)\n}\n</code></pre>"},{"location":"moretypes/#what-is-a-pointer","title":"What is a Pointer?","text":"<p>A pointer is a variable that stores the memory address of another variable.</p> <p>Think of it like:</p> <p>A house address (pointer) that tells you where the actual item (value) is stored.</p>"},{"location":"moretypes/#basic-example","title":"Basic Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 10        // x is a normal integer variable\n    p := &amp;x        // p is a pointer to x (holds the address of x)\n\n    fmt.Println(\"x =\", x)     // value of x\n    fmt.Println(\"p =\", p)     // address of x\n    fmt.Println(\"*p =\", *p)   // value stored at that address\n}\n</code></pre>"},{"location":"moretypes/#output-example","title":"Output (example)","text":"<pre><code>x = 10\np = 0xc000014090\n*p = 10\n</code></pre> <ul> <li><code>&amp;x</code> \u2192 gives the address of <code>x</code>.</li> <li><code>*p</code> \u2192 gets the value stored at that address.</li> </ul>"},{"location":"moretypes/#changing-values-via-pointers","title":"Changing Values via Pointers","text":"<p>If you modify a value using its pointer, it changes the original variable.</p> <pre><code>*p = 20\nfmt.Println(x)  // Output: 20\n</code></pre> <p>Because <code>p</code> points to <code>x</code>, updating <code>*p</code> means you\u2019re updating <code>x</code>.</p>"},{"location":"moretypes/#declaring-pointers-directly","title":"Declaring Pointers Directly","text":"<pre><code>var p *int // p is a pointer to int, but it\u2019s nil for now\nfmt.Println(p) // Output: &lt;nil&gt;\n</code></pre> <p>You can assign it later:</p> <pre><code>x := 42\np = &amp;x\n</code></pre>"},{"location":"moretypes/#functions-and-pointers","title":"Functions and Pointers","text":"<p>Go passes arguments by value, meaning it copies data. To modify a variable inside a function, use a pointer.</p> <pre><code>func update(num *int) {\n    *num = *num + 10\n}\n\nfunc main() {\n    x := 5\n    update(&amp;x)\n    fmt.Println(x) // Output: 15\n}\n</code></pre> <p>Using <code>&amp;x</code> passes the address, not the value \u2014 letting the function modify <code>x</code>.</p>"},{"location":"moretypes/#why-pointers-matter-real-backend-use","title":"Why Pointers Matter (Real Backend Use)","text":"<ol> <li>Performance: Avoid copying big structs or slices.</li> <li>Mutability: Allow functions to modify shared data.</li> <li>Nil checks: Optional fields in structs (similar to nullable references).</li> </ol> <p>Example with a struct:</p> <pre><code>type User struct {\n    Name string\n    Age  int\n}\n\nfunc updateUser(u *User) {\n    u.Age += 1\n}\n\nfunc main() {\n    user := User{Name: \"Njox\", Age: 21}\n    updateUser(&amp;user)\n    fmt.Println(user.Age) // Output: 22\n}\n</code></pre>"},{"location":"moretypes/#pointers-and-nil","title":"Pointers and Nil","text":"<p>A pointer with no address points to <code>nil</code>.</p> <pre><code>var p *int\nif p == nil {\n    fmt.Println(\"Pointer is nil\")\n}\n</code></pre> <p>You must allocate before using it:</p> <pre><code>p = new(int)\n*p = 100\nfmt.Println(*p) // Output: 100\n</code></pre>"},{"location":"moretypes/#recap-summary","title":"Recap Summary","text":"Concept Symbol Meaning <code>&amp;x</code> Address-of Get address of variable <code>*p</code> Dereference Get or set value at pointer <code>var p *int</code> Declaration p can point to an int <code>new(T)</code> Allocation Creates pointer to new T <code>nil</code> Zero value Uninitialized pointer"},{"location":"moretypes/#mini-challenge","title":"Mini Challenge","text":"<p>Try this out </p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    a := 5\n    b := &amp;a\n    fmt.Println(a, *b)\n\n    *b = 10\n    fmt.Println(a, *b)\n\n    c := new(int)\n    *c = 15\n    fmt.Println(*c)\n}\n</code></pre> <p>Can you explain what prints at each line?</p>"},{"location":"moretypes/#summary","title":"Summary","text":"Symbol Name Meaning Example Description <code>&amp;</code> Address-of / Referencing Gives you the memory address of a variable <code>p := &amp;x</code> \u201cPoint <code>p</code> to the address of <code>x</code>.\u201d <code>*</code> Dereference / Indirection Accesses the value stored at a memory address <code>*p = 10</code> \u201cGo to the address stored in <code>p</code> and set its value to 10.\u201d"},{"location":"moretypes/#example-to-see-both-in-action","title":"Example to See Both in Action","text":"<pre><code>x := 5\np := &amp;x   // referencing\nfmt.Println(p)   // prints memory address, e.g. 0xc0000180b0\nfmt.Println(*p)  // dereferencing \u2192 prints 5\n\n*p = 20          // modify the value at that address\nfmt.Println(x)   // prints 20\n</code></pre>"},{"location":"moretypes/#visual-memory-view","title":"Visual Memory View","text":"<pre><code>x:  [ 5 ]           \u2190 value\np:  [ address of x ] \u2192 0xc0000180b0\n*p: dereferences p \u2192 gives 5\n</code></pre> <p>So:</p> <ul> <li><code>&amp;x</code> = \u201cWhere is x?\u201d</li> <li><code>*p</code> = \u201cWhat\u2019s stored there?\u201d</li> </ul> <p>\ud83d\udd25 Perfect timing bro \u2014 you\u2019ve already mastered structs, so now let\u2019s take it one level higher: \ud83d\udc49 Pointers to Structs \u2014 how Go lets you modify struct data directly without copying.</p>"},{"location":"moretypes/#1-why-we-need-pointers-to-structs","title":"\ud83e\udde9 1. Why We Need Pointers to Structs","text":"<p>By default, structs are value types. That means assigning or passing them copies the entire struct.</p> <p>Example \ud83d\udc47</p> <pre><code>type User struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    u1 := User{\"Njox\", 22}\n    u2 := u1      // full copy\n    u2.Age = 30\n\n    fmt.Println(u1.Age) // 22 \u274c not changed\n    fmt.Println(u2.Age) // 30\n}\n</code></pre> <p>So <code>u2</code> is a separate copy \u2014 changing it doesn\u2019t affect <code>u1</code>.</p>"},{"location":"moretypes/#2-fixing-that-with-pointers","title":"\ud83e\udde0 2. Fixing That with Pointers","text":"<p>If we want both variables to point to the same memory, we use a pointer to the struct.</p> <pre><code>type User struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    u1 := User{\"Njox\", 22}\n    u2 := &amp;u1        // u2 is a pointer to u1\n\n    u2.Age = 30      // modify through the pointer\n\n    fmt.Println(u1.Age) // 30 \u2705 changed\n    fmt.Println(u2.Age) // 30 \u2705 same memory\n}\n</code></pre>"},{"location":"moretypes/#explanation","title":"\ud83e\udde9 Explanation:","text":"<ul> <li><code>&amp;u1</code> \u2192 gives the address of <code>u1</code></li> <li><code>u2</code> \u2192 stores that address (pointer)</li> <li><code>u2.Age</code> \u2192 Go automatically dereferences the pointer for you (shortcut for <code>(*u2).Age</code>)</li> </ul>"},{"location":"moretypes/#3-creating-a-pointer-struct-directly","title":"\u2699\ufe0f 3. Creating a Pointer Struct Directly","text":"<p>You can create a struct pointer without an existing variable using <code>new()</code> or <code>&amp;{}</code> syntax.</p> <pre><code>u := &amp;User{Name: \"Lee\", Age: 25}\nfmt.Println(u)       // prints pointer address\nfmt.Println(*u)      // prints full struct value\nfmt.Println(u.Name)  // access field directly\n</code></pre> <p>\u2705 Go lets you use <code>u.Name</code> even though <code>u</code> is a pointer \u2014 it automatically dereferences for you.</p>"},{"location":"moretypes/#4-passing-pointer-structs-to-functions","title":"\ud83e\uddf1 4. Passing Pointer Structs to Functions","text":"<p>This is common in backend apps \u2014 you pass a pointer so the function modifies the original struct.</p> <pre><code>func makeOlder(u *User) {\n    u.Age++\n}\n\nfunc main() {\n    user := User{\"Njox\", 22}\n    makeOlder(&amp;user)\n    fmt.Println(user.Age) // 23 \u2705 modified\n}\n</code></pre> <ul> <li>We pass <code>&amp;user</code> (the address)</li> <li>The function uses <code>*User</code> (pointer receiver)</li> <li>The original struct changes directly</li> </ul>"},{"location":"moretypes/#5-pointer-shortcut-recap","title":"\ud83e\udde0 5. Pointer Shortcut Recap","text":"Expression Meaning <code>&amp;x</code> Get the address of <code>x</code> <code>*p</code> Get the value stored at pointer <code>p</code> <code>p := &amp;User{}</code> Pointer to new struct <code>p.Name</code> Go auto-dereferences (you can use this directly)"},{"location":"moretypes/#example-full-demo","title":"\u26a1 Example: Full Demo","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype Product struct {\n    Name  string\n    Price float64\n}\n\nfunc discount(p *Product, percent float64) {\n    p.Price = p.Price - (p.Price * percent / 100)\n}\n\nfunc main() {\n    prod := Product{\"Laptop\", 1000}\n    discount(&amp;prod, 10)\n    fmt.Println(prod) // {Laptop 900}\n}\n</code></pre> <p>\u2705 The function modifies the original <code>prod</code> because it receives a pointer.</p>"},{"location":"moretypes/#summary_1","title":"\ud83d\udd25 Summary","text":"Concept Without Pointer With Pointer Memory Copies struct References same struct Function edits Doesn\u2019t affect original Updates original Common use Reading data Updating data <p>So now you can:</p> <ul> <li>Create structs \u2705</li> <li>Use pointers to structs \u2705</li> <li>Modify data directly \u2705</li> </ul> <p>Next step (and it\u2019s where Go shines in backend dev): \ud83d\udc49 Pointer Receivers in Struct Methods \u2014 attaching functions to structs so they can mutate data directly (like classes in OOP).</p> <p>Do you want to move to that next?</p>"},{"location":"moretypes/functions/","title":"1. Function Values","text":"<p>In Go, functions are first-class citizens, meaning you can:</p> <ul> <li>Assign functions to variables</li> <li>Pass functions as arguments</li> <li>Return functions from other functions</li> </ul>"},{"location":"moretypes/functions/#example-1-assigning-a-function-to-a-variable","title":"Example 1 \u2014 Assigning a function to a variable","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc add(a, b int) int {\n    return a + b\n}\n\nfunc main() {\n    var f func(int, int) int  // declare a variable of function type\n    f = add                    // assign function to variable\n    result := f(3, 4)\n    fmt.Println(result)        // 7\n}\n</code></pre> <p>Use case: Dynamic behavior selection, callbacks, or strategy patterns.</p>"},{"location":"moretypes/functions/#example-2-passing-a-function-as-argument","title":"Example 2 \u2014 Passing a function as argument","text":"<pre><code>func apply(a, b int, op func(int, int) int) int {\n    return op(a, b)\n}\n\nfunc main() {\n    sum := func(x, y int) int { return x + y }\n    product := func(x, y int) int { return x * y }\n\n    fmt.Println(apply(3, 4, sum))     // 7\n    fmt.Println(apply(3, 4, product)) // 12\n}\n</code></pre> <p>Use case: Higher-order functions, reusable computation logic.</p>"},{"location":"moretypes/functions/#2-function-closures","title":"2. Function Closures","text":"<p>A closure is a function that captures variables from its surrounding scope.</p> <pre><code>func adder() func(int) int {\n    sum := 0\n    return func(x int) int {\n        sum += x\n        return sum\n    }\n}\n\nfunc main() {\n    posSum := adder()\n    fmt.Println(posSum(1)) // 1\n    fmt.Println(posSum(2)) // 3\n    fmt.Println(posSum(3)) // 6\n}\n</code></pre> <ul> <li>The returned function remembers <code>sum</code> even after <code>adder()</code> has finished.</li> <li>Closures are useful for maintaining state between calls without global variables.</li> </ul> <p>Use case: Counters, memoization, event handlers.</p>"},{"location":"moretypes/functions/#step-by-step-quizzes","title":"Step-by-step quizzes","text":""},{"location":"moretypes/functions/#beginner","title":"Beginner","text":""},{"location":"moretypes/functions/#quiz-1-function-value-assignment","title":"Quiz 1 \u2014 Function value assignment","text":"<ol> <li>Write a function <code>greet(name string) string</code> that returns <code>\"Hello, &lt;name&gt;\"</code>.</li> <li>Assign it to a variable <code>f</code> and call <code>f(\"Alice\")</code>.</li> <li>Print the result.</li> </ol> <p>Use case: Simple dynamic greetings or callback examples.</p>"},{"location":"moretypes/functions/#quiz-2-function-as-argument","title":"Quiz 2 \u2014 Function as argument","text":"<ol> <li>Write two functions: <code>square(n int) int</code> and <code>cube(n int) int</code>.</li> <li>Write a higher-order function <code>compute(n int, fn func(int) int) int</code> that applies <code>fn</code> to <code>n</code>.</li> <li>Test <code>compute(3, square)</code> and <code>compute(2, cube)</code>.</li> </ol> <p>Use case: Dynamic computation pipelines, reusable processing.</p>"},{"location":"moretypes/functions/#intermediate","title":"Intermediate","text":""},{"location":"moretypes/functions/#quiz-3-closure-as-counter","title":"Quiz 3 \u2014 Closure as counter","text":"<ol> <li>Write a function <code>counter()</code> that returns a closure <code>func() int</code> which increments and returns a number every time it\u2019s called.</li> <li>Create two counters <code>c1</code> and <code>c2</code> and show they maintain separate counts.</li> </ol> <p>Use case: Unique ID generators, counters in a package.</p>"},{"location":"moretypes/functions/#quiz-4-accumulator","title":"Quiz 4 \u2014 Accumulator","text":"<ol> <li>Write a function <code>accumulator(start int)</code> that returns a closure <code>func(int) int</code>.</li> <li>Each call of the closure adds the argument to a running total starting from <code>start</code>.</li> <li>Test with a few numbers.</li> </ol> <p>Use case: Financial transactions or running totals in a program.</p>"},{"location":"moretypes/functions/#advanced","title":"Advanced","text":""},{"location":"moretypes/functions/#quiz-5-memoization-with-closure","title":"Quiz 5 \u2014 Memoization with closure","text":"<ol> <li>Write a function <code>FibMemo()</code> that returns a closure <code>func(n int) int</code>.</li> <li>The closure calculates Fibonacci numbers and stores previously calculated results in a map.</li> <li>Test <code>FibMemo()(10)</code> and observe speed improvements on repeated calls.</li> </ol> <p>Use case: Optimize expensive recursive calculations dynamically.</p>"},{"location":"moretypes/functions/#quiz-6-function-returning-different-operations","title":"Quiz 6 \u2014 Function returning different operations","text":"<ol> <li>Write a function <code>operation(op string) func(int, int) int</code> which returns a closure performing addition, subtraction, multiplication, or division depending on <code>op</code>.</li> <li>Test <code>operation(\"add\")(3, 5)</code> and <code>operation(\"mul\")(2, 4)</code>.</li> </ol> <p>Use case: Dynamic command processing or calculator design.</p>"},{"location":"moretypes/functions/#quiz-7-stateful-event-handlers","title":"Quiz 7 \u2014 Stateful event handlers","text":"<ol> <li>Write a closure <code>logger(prefix string)</code> that returns <code>func(msg string)</code> and prints <code>\"[prefix] msg\"</code> every time it\u2019s called.</li> <li>Create two loggers <code>infoLogger</code> and <code>errorLogger</code> with different prefixes.</li> <li>Call them with messages and observe how each keeps its prefix.</li> </ol> <p>Use case: Logging system with different contexts.</p>"},{"location":"moretypes/functions/#key-notes","title":"Key notes","text":"<ol> <li>Function values can be stored, passed, or returned like any other variable.</li> <li>Closures capture the surrounding environment.</li> <li>Use closures for stateful functions without global variables.</li> <li>Higher-order functions make your code flexible and reusable.</li> </ol>"},{"location":"moretypes/map/","title":"What is a map?","text":"<p>A map is an unordered collection of key \u2192 value pairs. Keys must be of a comparable type (strings, ints, pointers, structs with comparable fields, etc.). Maps are reference types and grow dynamically.</p> <p>Basic form:</p> <pre><code>var m map[string]int          // nil map, must be initialized before use\nm = make(map[string]int)     // initialize with make\nm[\"apple\"] = 5               // set\nv := m[\"apple\"]              // get (zero value if absent)\nv, ok := m[\"apple\"]          // comma-ok form to check presence\ndelete(m, \"apple\")           // remove key\n</code></pre> <p>Common uses</p> <ul> <li>Frequency counters (word/char counts)</li> <li>Caches and memoization</li> <li>Lookups (user ID \u2192 profile)</li> <li>Indexes (value \u2192 positions)</li> <li>Adjacency lists for graphs</li> </ul>"},{"location":"moretypes/map/#quick-reference-examples","title":"Quick reference examples","text":"<p>Create and initialize:</p> <pre><code>m := map[string]int{\n    \"alice\": 30,\n    \"bob\":   25,\n}\n</code></pre> <p>Add / modify / read:</p> <pre><code>m[\"carol\"] = 28\nage := m[\"alice\"]\nage, ok := m[\"dan\"]  // ok == false if \"dan\" not present\n</code></pre> <p>Delete and length:</p> <pre><code>delete(m, \"bob\")\nfmt.Println(len(m))\n</code></pre> <p>Iterate (order not guaranteed):</p> <pre><code>for k, v := range m {\n    fmt.Println(k, v)\n}\n</code></pre> <p>Nested maps:</p> <pre><code>nested := make(map[string]map[string]int)\nnested[\"group1\"] = make(map[string]int)\nnested[\"group1\"][\"x\"] = 1\n</code></pre> <p>Map keys constraints:</p> <ul> <li>Keys must be comparable (<code>==</code> allowed). Slices, maps, and functions cannot be keys.</li> </ul>"},{"location":"moretypes/map/#step-by-step-quizzes-no-answers-included","title":"Step-by-step quizzes (no answers included)","text":"<p>Each task includes code skeleton + steps. Run <code>go run</code> / <code>go test</code> to validate your work.</p>"},{"location":"moretypes/map/#beginner","title":"Beginner","text":""},{"location":"moretypes/map/#quiz-1-basic-creation-access","title":"Quiz 1 \u2014 Basic creation &amp; access","text":"<ol> <li>Create a file <code>quiz1.go</code>.</li> <li>Create and initialize a map <code>ages</code> with entries: <code>\"Alice\": 30</code>, <code>\"Bob\": 25</code>.</li> <li>Print the age of <code>\"Alice\"</code>.</li> <li>Read <code>\"Charlie\"</code> from the map using comma-ok and print whether the key exists.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 1. create and initialize ages\n    // 2. print ages[\"Alice\"]\n    // 3. read ages[\"Charlie\"] with comma-ok and print existence\n}\n</code></pre> <p>Use-case: simple lookup table for user age.</p>"},{"location":"moretypes/map/#quiz-2-add-modify-delete","title":"Quiz 2 \u2014 Add / modify / delete","text":"<ol> <li>Start with an empty map <code>inventory := make(map[string]int)</code>.</li> <li>Add <code>\"apple\": 10</code>, <code>\"banana\": 5</code>.</li> <li>Increase apple by 5.</li> <li>Remove <code>\"banana\"</code>.</li> <li>Print final map and its length.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    inventory := make(map[string]int)\n    // steps...\n}\n</code></pre> <p>Use-case: inventory counts in a small store.</p>"},{"location":"moretypes/map/#intermediate","title":"Intermediate","text":""},{"location":"moretypes/map/#quiz-3-frequency-counter","title":"Quiz 3 \u2014 Frequency counter","text":"<ol> <li>Write a function <code>WordCount(s string) map[string]int</code> that returns counts of words separated by spaces.</li> <li>Test with <code>\"go go gopher go\"</code>.</li> <li>Print top 2 words by count (just iterate and identify).</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc WordCount(s string) map[string]int {\n    // implement\n}\n\nfunc main() {\n    counts := WordCount(\"go go gopher go\")\n    fmt.Println(counts)\n}\n</code></pre> <p>Use-case: text analytics / simple log analysis.</p>"},{"location":"moretypes/map/#quiz-4-map-with-struct-values","title":"Quiz 4 \u2014 Map with struct values","text":"<ol> <li>Define <code>type User struct { Name string; Email string }</code>.</li> <li>Create <code>users := make(map[int]User)</code> (map user ID \u2192 User).</li> <li>Add at least two users.</li> <li>Update one user\u2019s email (show how to read-modify-write).</li> <li>Print all users.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype User struct {\n    Name  string\n    Email string\n}\n\nfunc main() {\n    users := make(map[int]User)\n    // steps...\n}\n</code></pre> <p>Use-case: in-memory user store.</p>"},{"location":"moretypes/map/#quiz-5-map-of-slices-groups","title":"Quiz 5 \u2014 Map of slices (groups)","text":"<ol> <li>Create <code>groups := make(map[string][]string)</code>.</li> <li>Add members to group <code>\"admins\"</code> and <code>\"devs\"</code>.</li> <li>Append another member to <code>\"devs\"</code>.</li> <li>Iterate and print each group and members.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    groups := make(map[string][]string)\n    // steps...\n}\n</code></pre> <p>Use-case: grouping users by roles.</p>"},{"location":"moretypes/map/#advanced","title":"Advanced","text":""},{"location":"moretypes/map/#quiz-6-nested-maps-initialization-helper","title":"Quiz 6 \u2014 Nested maps &amp; initialization helper","text":"<ol> <li>Create <code>permissions := make(map[string]map[string]bool)</code> where outer key is username, inner map is permission \u2192 bool.</li> <li>Write helper <code>func SetPerm(m map[string]map[string]bool, user, perm string, value bool)</code> that ensures inner map is initialized before setting.</li> <li>Set a few permissions and print them.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc SetPerm(m map[string]map[string]bool, user, perm string, value bool) {\n    // ensure inner map exists, then set\n}\n\nfunc main() {\n    perms := make(map[string]map[string]bool)\n    // use SetPerm and print results\n}\n</code></pre> <p>Use-case: per-user permission matrix in a service.</p>"},{"location":"moretypes/map/#quiz-7-map-concurrency-warning-safe-access","title":"Quiz 7 \u2014 Map concurrency warning &amp; safe access","text":"<ol> <li>Create a read-heavy simulation where multiple goroutines read from a shared map concurrently.</li> <li>Demonstrate that writing to the map concurrently can panic.</li> <li>Refactor to use <code>sync.RWMutex</code> to safely support concurrent reads and occasional writes.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc main() {\n    m := make(map[int]string)\n    // populate m\n\n    // start many goroutines that read m\n\n    // optionally start goroutine that writes to m (show panic without mutex, fix with mutex)\n}\n</code></pre> <p>Use-case: shared in-memory cache in concurrent server.</p>"},{"location":"moretypes/map/#quiz-8-graph-adjacency-list","title":"Quiz 8 \u2014 Graph adjacency list","text":"<ol> <li>Use a map to represent an undirected graph: <code>graph := make(map[string][]string)</code>.</li> <li>Implement <code>AddEdge(g map[string][]string, a, b string)</code> that adds an edge both ways.</li> <li>Implement <code>Neighbors(g map[string][]string, node string) []string</code>.</li> <li>Build a small graph, print neighbors of a node, and perform a simple BFS to find if two nodes are connected.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc AddEdge(g map[string][]string, a, b string) {\n    // add both directions\n}\n\nfunc Neighbors(g map[string][]string, node string) []string {\n    return g[node]\n}\n\nfunc main() {\n    g := make(map[string][]string)\n    // build graph, print neighbors, BFS simple connectivity\n}\n</code></pre> <p>Use-case: routing, network topology, recommendation engines.</p>"},{"location":"moretypes/map/#quiz-9-map-key-constraints-custom-key","title":"Quiz 9 \u2014 Map key constraints &amp; custom key","text":"<ol> <li>Define <code>type Point struct { X, Y int }</code> and use <code>map[Point]string</code> (color).</li> <li>Insert a few points and read them.</li> <li>Try to use a slice as a key and observe the compiler error \u2014 explain why slices cannot be map keys.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype Point struct { X, Y int }\n\nfunc main() {\n    m := make(map[Point]string)\n    m[Point{1,2}] = \"red\"\n    fmt.Println(m[Point{1,2}])\n    // try map[[]int]string // should not compile\n}\n</code></pre> <p>Use-case: spatial indexing, quick lookups for coordinate-based data.</p>"},{"location":"moretypes/map/#quiz-10-large-scale-memoization","title":"Quiz 10 \u2014 Large-scale memoization","text":"<ol> <li>Implement a Fibonacci with memoization using <code>map[int]int</code> to cache results: <code>func Fib(n int, memo map[int]int) int</code>.</li> <li>Measure time with and without memoization for n=40.</li> <li>Discuss memory/time tradeoffs.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc Fib(n int, memo map[int]int) int {\n    // implement with memo\n}\n\nfunc main() {\n    memo := make(map[int]int)\n    start := time.Now()\n    fmt.Println(Fib(40, memo))\n    fmt.Println(\"Elapsed:\", time.Since(start))\n}\n</code></pre> <p>Use-case: dynamic programming optimization, expensive computation caching.</p>"},{"location":"moretypes/map/#extra-tips-gotchas","title":"Extra tips &amp; gotchas","text":"<ul> <li>Maps are reference types: passing to functions gives access to same underlying data.</li> <li>Reading from a nil map returns zero value; writing to a nil map causes panic. Always initialize (<code>make</code>) before write.</li> <li>Maps are not safe for concurrent writes \u2014 use sync.Mutex or sync.RWMutex or <code>sync.Map</code> for concurrent access.</li> <li>Map iteration order is random; do not rely on ordering. If order matters, use a slice of keys and sort it.</li> </ul>"},{"location":"moretypes/slices/","title":"Slices","text":""},{"location":"moretypes/slices/#1-slices-are-reference-types","title":"1. Slices are Reference Types","text":"<p>Remember: slices point to an underlying array. Modifying a slice can affect the original array.</p> <pre><code>arr := [5]int{1, 2, 3, 4, 5}\nslice := arr[1:4] // [2 3 4]\nslice[0] = 20\nfmt.Println(arr)  // [1 20 3 4 5]\n</code></pre> <p>Changing <code>slice[0]</code> also changes <code>arr[1]</code> because the slice shares the same array.</p>"},{"location":"moretypes/slices/#2-slice-length-and-capacity","title":"2. Slice Length and Capacity","text":"<p>Every slice has:</p> <ul> <li>Length (<code>len</code>) \u2192 number of accessible elements</li> <li>Capacity (<code>cap</code>) \u2192 max elements before a new array is allocated</li> </ul> <pre><code>s := []int{1, 2, 3, 4, 5}\nfmt.Println(len(s)) // 5\nfmt.Println(cap(s)) // 5\n\ns = s[:3]           // slice first 3 elements\nfmt.Println(len(s)) // 3\nfmt.Println(cap(s)) // 5 (capacity is still based on underlying array)\n</code></pre>"},{"location":"moretypes/slices/#3-appending-to-a-slice","title":"3. Appending to a Slice","text":"<p>Use <code>append()</code> to add elements. If capacity is exceeded, Go allocates a new underlying array.</p> <pre><code>s := []int{1, 2, 3}\nfmt.Println(len(s), cap(s)) // 3 3\n\ns = append(s, 4)\nfmt.Println(s)               // [1 2 3 4]\nfmt.Println(len(s), cap(s))  // 4 6 (capacity increased automatically)\n</code></pre> <p>Important: always assign back to the slice (<code>s = append(s, ...)</code>) because append may return a new slice.</p>"},{"location":"moretypes/slices/#4-copying-slices","title":"4. Copying Slices","text":"<p>Sometimes you want to avoid modifying the original slice.</p> <pre><code>original := []int{1, 2, 3}\ncopySlice := make([]int, len(original))\ncopy(copySlice, original)\n\ncopySlice[0] = 100\nfmt.Println(original)  // [1 2 3]\nfmt.Println(copySlice) // [100 2 3]\n</code></pre> <p><code>copy()</code> copies elements from one slice to another.</p>"},{"location":"moretypes/slices/#5-slicing-a-slice","title":"5. Slicing a Slice","text":"<p>Slices can be sliced multiple times:</p> <pre><code>s := []int{10, 20, 30, 40, 50}\ns1 := s[1:4] // [20 30 40]\ns2 := s[:3]  // [10 20 30]\ns3 := s[2:]  // [30 40 50]\n\nfmt.Println(s1, s2, s3)\n</code></pre>"},{"location":"moretypes/slices/#6-common-slice-interview-questions","title":"6. Common Slice Interview Questions","text":"<ul> <li>What happens if you append beyond the slice\u2019s capacity?</li> <li>How do slices differ from arrays in memory?</li> <li>Show how modifying a slice can affect its underlying array.</li> <li>Write a function that removes an element at a given index from a slice in place.</li> </ul>"},{"location":"moretypes/slices/#mini-challenge","title":"Mini Challenge","text":"<ol> <li>Create a slice of integers: <code>[10, 20, 30, 40]</code></li> <li>Append <code>50</code> and <code>60</code></li> <li>Slice it to <code>[20, 30, 40, 50]</code></li> <li>Modify the first element of the new slice to <code>99</code></li> <li>Print both the original and new slice \u2014 see what changed</li> </ol>"},{"location":"moretypes/slices/#1-make-syntax","title":"1. <code>make</code> Syntax","text":"<pre><code>slice := make([]Type, length, capacity)\n</code></pre> <ul> <li><code>Type</code> \u2192 the type of elements (<code>int</code>, <code>string</code>, etc.)</li> <li><code>length</code> \u2192 number of elements initially accessible</li> <li><code>capacity</code> \u2192 maximum number of elements before Go allocates a new underlying array</li> </ul> <p>If you omit <code>capacity</code>, it defaults to <code>length</code>.</p>"},{"location":"moretypes/slices/#2-example-with-integers","title":"2. Example with Integers","text":"<pre><code>numbers := make([]int, 3, 5) // length = 3, capacity = 5\nfmt.Println(numbers)         // [0 0 0] \u2192 zero values\nfmt.Println(len(numbers))    // 3\nfmt.Println(cap(numbers))    // 5\n</code></pre> <ul> <li><code>numbers</code> has space for 5 elements, but currently only 3 are accessible.</li> </ul>"},{"location":"moretypes/slices/#3-example-with-strings","title":"3. Example with Strings","text":"<pre><code>names := make([]string, 2)\nfmt.Println(names)      // [\"\" \"\"] \u2192 zero value for strings\nfmt.Println(len(names)) // 2\nfmt.Println(cap(names)) // 2 (capacity defaults to length)\n</code></pre>"},{"location":"moretypes/slices/#4-appending-to-a-slice-created-with-make","title":"4. Appending to a Slice Created with <code>make</code>","text":"<pre><code>nums := make([]int, 2, 4)\nnums[0] = 10\nnums[1] = 20\n\nnums = append(nums, 30, 40) // adding elements within capacity\nfmt.Println(nums)            // [10 20 30 40]\nfmt.Println(len(nums))       // 4\nfmt.Println(cap(nums))       // 4\n\nnums = append(nums, 50)      // exceeds capacity, Go allocates a new array\nfmt.Println(nums)            // [10 20 30 40 50]\nfmt.Println(len(nums))       // 5\nfmt.Println(cap(nums))       // 8 (capacity doubled automatically)\n</code></pre>"},{"location":"moretypes/slices/#key-points","title":"Key Points","text":"<ul> <li><code>make</code> creates a slice with pre-allocated memory, which is useful for performance if you know the approximate size.</li> <li>Length \u2264 Capacity</li> <li><code>append</code> can grow the slice beyond capacity; Go handles reallocation automatically.</li> <li>Uninitialized elements are set to the zero value of their type (<code>0</code> for numbers, <code>\"\"</code> for strings, <code>false</code> for booleans).</li> </ul>"},{"location":"moretypes/slices/#beginner","title":"BEGINNER","text":"<p>1. Create a slice with make</p> <ul> <li>Create a slice of integers with length 3 and capacity 5.</li> <li>Assign values 10, 20, 30 to the slice.</li> <li>Print the slice, its length, and capacity.</li> </ul> <p>2. Append elements</p> <ul> <li>Append 40 and 50 to the slice from exercise 1.</li> <li>Print the slice, its length, and capacity.</li> <li>Append 60 and observe what happens to the capacity.</li> </ul> <p>3. Zero values</p> <ul> <li>Create a slice of strings with length 4 using <code>make</code>.</li> <li>Print the slice and explain the output.</li> </ul>"},{"location":"moretypes/slices/#intermediate","title":"INTERMEDIATE","text":"<p>4. Slicing a slice</p> <ul> <li>Create a slice <code>nums := make([]int, 5, 10)</code> and assign values 1 to 5.</li> <li>Slice it to get <code>[2,3,4]</code> using slicing syntax.</li> <li>Modify the first element of the new slice to 99.</li> <li>Print both the original slice and the new slice. What changed and why?</li> </ul> <p>5. Function that modifies a slice</p> <ul> <li>Write a function <code>DoubleValues(nums []int)</code> that doubles each element of a slice.</li> <li>Pass a slice created with <code>make</code> to it.</li> <li>Print the slice before and after the function call.</li> </ul> <p>6. Copying slices</p> <ul> <li>Create a slice with <code>make</code> and copy it to a new slice using <code>copy()</code>.</li> <li>Modify the new slice and print both slices. Does the original change? Explain.</li> </ul>"},{"location":"moretypes/slices/#advanced","title":"ADVANCED","text":"<p>7. Removing an element in-place</p> <ul> <li>Create a slice of integers with length 5 using <code>make</code>.</li> <li>Write a function <code>RemoveIndex(s []int, index int) []int</code> that removes an element at a given index without creating a new slice.</li> <li>Test it by removing the 2nd element. Print the resulting slice.</li> </ul> <p>8. Slice growth and capacity</p> <ul> <li>Create a slice <code>s := make([]int, 2, 4)</code> and append elements to exceed the capacity.</li> <li>Print the slice, its length, and capacity after each append.</li> <li>Explain how Go handles slice growth internally.</li> </ul> <p>9. Multi-dimensional slice with make</p> <ul> <li>Create a 2D slice (matrix) with 3 rows and 4 columns using <code>make</code>.</li> <li>Assign values such that <code>matrix[i][j] = i*4 + j + 1</code>.</li> <li>Print the matrix in a readable format.</li> </ul> <p>10. Combined pointer + slice exercise</p> <ul> <li>Create a struct <code>Product</code> with fields <code>Name</code> and <code>Stock</code>.</li> <li>Create a slice of <code>Product</code> pointers using <code>make</code>.</li> <li>Write a function <code>Restock(products []*Product, n int)</code> that increases stock for all products.</li> <li>Test by printing before and after restocking.</li> </ul>"},{"location":"projects/projects/","title":"Beginner \u2192 Intermediate \u2192 Advanced Go Projects","text":""},{"location":"projects/projects/#1-command-line-calculator-beginner","title":"1. Command-line Calculator (Beginner)","text":"<ul> <li> <p>Features:</p> </li> <li> <p>Supports addition, subtraction, multiplication, division</p> </li> <li> <p>Uses functions, function values, and method receivers</p> </li> <li> <p>What you\u2019ll learn:</p> </li> <li> <p>Function values, method receivers, closures for custom operations</p> </li> <li> <p>Extensions:</p> </li> <li> <p>Add factorial, power, and Fibonacci operations</p> </li> </ul>"},{"location":"projects/projects/#2-fibonacci-prime-number-generator-beginner-intermediate","title":"2. Fibonacci &amp; Prime Number Generator (Beginner \u2192 Intermediate)","text":"<ul> <li> <p>Features:</p> </li> <li> <p>Generate first N Fibonacci numbers</p> </li> <li>Check if a number is prime</li> <li> <p>Generate all primes up to N</p> </li> <li> <p>What you\u2019ll learn:</p> </li> <li> <p>Loops, slices, maps, closures, function values</p> </li> <li> <p>Memoization with maps</p> </li> <li> <p>Extensions:</p> </li> <li> <p>Write a memoized Fibonacci closure</p> </li> <li>Count prime frequencies in a given range</li> </ul>"},{"location":"projects/projects/#3-stateful-counter-with-closures-intermediate","title":"3. Stateful Counter with Closures (Intermediate)","text":"<ul> <li> <p>Features:</p> </li> <li> <p>Create multiple counters with different step sizes</p> </li> <li> <p>Use closures to increment</p> </li> <li> <p>What you\u2019ll learn:</p> </li> <li> <p>Structs, pointer receivers, closures</p> </li> <li> <p>Encapsulation of state</p> </li> <li> <p>Extensions:</p> </li> <li> <p>Store counters in a slice and iterate them dynamically</p> </li> </ul>"},{"location":"projects/projects/#4-word-frequency-analyzer-intermediate","title":"4. Word Frequency Analyzer (Intermediate)","text":"<ul> <li> <p>Features:</p> </li> <li> <p>Reads a text file (or a string)</p> </li> <li> <p>Counts frequency of each word</p> </li> <li> <p>What you\u2019ll learn:</p> </li> <li> <p>Maps, slices, strings, functions</p> </li> <li> <p>Function as argument (e.g., pass a filter function)</p> </li> <li> <p>Extensions:</p> </li> <li> <p>Return top N words</p> </li> <li>Use closures to filter stopwords</li> </ul>"},{"location":"projects/projects/#5-stack-queue-implementations-intermediate","title":"5. Stack &amp; Queue Implementations (Intermediate)","text":"<ul> <li> <p>Features:</p> </li> <li> <p>Implement stack with push/pop</p> </li> <li>Implement queue with enqueue/dequeue</li> <li> <p>Use slices and pointers</p> </li> <li> <p>What you\u2019ll learn:</p> </li> <li> <p>Pointers, slices, methods</p> </li> <li> <p>Extensions:</p> </li> <li> <p>Implement a stack of structs (e.g., Task struct)</p> </li> </ul>"},{"location":"projects/projects/#6-matrix-operations-intermediate-advanced","title":"6. Matrix Operations (Intermediate \u2192 Advanced)","text":"<ul> <li> <p>Features:</p> </li> <li> <p>Create 2D slices for matrices</p> </li> <li> <p>Implement addition, multiplication, and transpose</p> </li> <li> <p>What you\u2019ll learn:</p> </li> <li> <p>Multi-dimensional slices, loops, methods</p> </li> <li> <p>Extensions:</p> </li> <li> <p>Implement determinant calculation using recursion</p> </li> </ul>"},{"location":"projects/projects/#7-simple-banking-system-advanced","title":"7. Simple Banking System (Advanced)","text":"<ul> <li> <p>Features:</p> </li> <li> <p>Account struct with balance</p> </li> <li>Methods: Deposit, Withdraw, Transfer</li> <li> <p>Closures for transaction logs or statement generation</p> </li> <li> <p>What you\u2019ll learn:</p> </li> <li> <p>Structs, pointer receivers, closures, maps for accounts</p> </li> <li> <p>Extensions:</p> </li> <li> <p>Slice of pointers to accounts</p> </li> <li>Track transaction history per account using slices</li> </ul>"},{"location":"projects/projects/#8-graph-algorithms-advanced","title":"8. Graph Algorithms (Advanced)","text":"<ul> <li> <p>Features:</p> </li> <li> <p>Represent a graph using map[string][]string (adjacency list)</p> </li> <li> <p>Implement BFS and DFS</p> </li> <li> <p>What you\u2019ll learn:</p> </li> <li> <p>Maps, slices, recursion, structs</p> </li> <li> <p>Extensions:</p> </li> <li> <p>Track visited nodes with maps</p> </li> <li>Implement shortest path (Dijkstra\u2019s basic version)</li> </ul>"},{"location":"projects/projects/#9-memoization-dynamic-programming-library-advanced","title":"9. Memoization / Dynamic Programming Library (Advanced)","text":"<ul> <li> <p>Features:</p> </li> <li> <p>Create reusable closure-based memoization for expensive functions</p> </li> <li> <p>Examples: Fibonacci, factorial, combinatorics</p> </li> <li> <p>What you\u2019ll learn:</p> </li> <li> <p>Closures, maps, function values, recursion</p> </li> <li> <p>Extensions:</p> </li> <li> <p>Generic memoization function that works for different types (Go 1.18+ generics)</p> </li> </ul>"},{"location":"projects/projects/#10-cli-number-puzzle-solver-advanced","title":"10. CLI Number Puzzle Solver (Advanced)","text":"<ul> <li> <p>Features:</p> </li> <li> <p>Solve small number puzzles (like 8-puzzle or Sudoku mini version)</p> </li> <li>Represent the board as a slice of slices</li> <li> <p>Use functions and closures for move validation</p> </li> <li> <p>What you\u2019ll learn:</p> </li> <li> <p>Slices, structs, maps, methods, recursion</p> </li> <li> <p>Extensions:</p> </li> <li> <p>Track moves using slice of structs</p> </li> <li>Implement simple backtracking algorithm</li> </ul>"},{"location":"questions/","title":"Index","text":"<p>While direct community-driven localization for the official Go documentation isn't a standard, immediate process like for some other projects, your contribution of Swahili localization would be valuable and likely welcomed through the established Go contribution process, especially for the Go Wiki or specific non-core documentation.</p> <p>The Go project uses a rigorous contribution workflow centered around Gerrit, rather than typical GitHub Pull Requests, for core projects like the main documentation.</p> <p>Here is the step-by-step process you should follow, focusing on the Go community's official channels:</p>"},{"location":"questions/#1-determine-the-best-project-and-discuss","title":"1. \ud83d\udce7 Determine the Best Project and Discuss","text":"<p>Localization efforts for documentation often start as a community project or are managed in a separate repository under the <code>golang.org/x/</code> umbrella (for extra tools/repos).</p> <ul> <li>Consult the Go Wiki: Check the Go Wiki and the <code>go.googlesource.com/website</code> repository (which serves the Go website and documentation) for any existing information about localization efforts or a specific localization/i18n repository.</li> <li>Start a Discussion: The most critical first step is to propose your idea to the Go community to ensure your effort is coordinated and approved.</li> <li>Mailing List: The <code>golang-dev</code> or <code>golang-nuts</code> mailing lists are the official channels for proposing changes and discussing development. Search them first for existing localization discussions and then post your proposal for Swahili localization.</li> <li>Issue Tracker: If you can't find a localization process, you might consider opening an issue in the Go issue tracker (using the prefix <code>wiki:</code> or similar if targeting documentation) to propose the new language addition and ask for guidance on the correct repository and workflow.</li> </ul>"},{"location":"questions/#2-complete-official-contribution-prerequisites","title":"2. \ud83d\udcdd Complete Official Contribution Prerequisites","text":"<p>Before submitting any changes to an official Go project, you must complete the legal and technical setup:</p> <ul> <li>Contributor License Agreement (CLA): You must sign and submit a CLA to Google, granting them the rights to use your contributions. This is mandatory for all contributions.</li> <li>Gerrit Registration: The Go project uses Gerrit for code review (not GitHub Pull Requests for core repositories).</li> <li>Generate Credentials: Visit <code>go.googlesource.com</code>, click \"Generate Password,\" and follow the instructions to set up authentication.</li> <li>Register: Visit the Gerrit registration page to register your account.</li> <li>Install <code>git-codereview</code>: This tool helps format your commits for Gerrit. Run:   <code>bash   go install golang.org/x/review/git-codereview@latest</code></li> </ul>"},{"location":"questions/#3-clone-the-repository","title":"3. \ud83d\udee0\ufe0f Clone the Repository","text":"<p>Once you have clarity on where to contribute (likely the <code>go.googlesource.com/website</code> repo or a designated localization repo/wiki), clone the source:</p> <pre><code># Clone the website repository (where much of the documentation lives)\ngit clone https://go.googlesource.com/website\ncd website\n</code></pre>"},{"location":"questions/#4-create-and-submit-your-swahili-localization","title":"4. \u270d\ufe0f Create and Submit Your Swahili Localization","text":"<p>The process for translation usually involves creating a new directory structure for the language tag, which for Swahili would be <code>sw</code> or <code>sw-TZ</code> (Tanzania) / <code>sw-KE</code> (Kenya) depending on the accepted language code. You'll need to check the existing structure for other languages.</p> <ol> <li>Create a New Branch: <code>bash     git checkout -b swahili-docs-localization</code></li> <li>Add Translation Files: Create the necessary Swahili-localized documentation files based on the structure of the English documentation and any existing localized versions.</li> <li>Commit Your Changes: Use the special <code>git codereview</code> tool for committing:     <code>bash     git add [your new or modified files]     git codereview change     # Write a clear commit message in the editor that opens.</code></li> <li>Upload to Gerrit: Use the <code>git codereview</code> tool to submit your change for review:     <code>bash     git codereview mail</code></li> </ol> <p>A reviewer from the Go team will examine your change on Gerrit and provide feedback until your Swahili localization is ready to be merged.</p> <ul> <li>what is <code>GOPATH</code> and what does it mean?</li> <li>How are languages programming languages playgrounds made?</li> <li>What are golang packages and how they work.</li> <li>Create a golang calculator using packages.</li> <li>what are modules and packages in golang and what are their difference with real world examples.   That's a great set of questions covering fundamental concepts in Go development! Here are the answers, followed by a complete Go calculator example using packages.</li> </ul>"},{"location":"questions/#gopath-definition-and-meaning","title":"\ud83d\udcbb <code>GOPATH</code>: Definition and Meaning","text":"<p>The term <code>GOPATH</code> historically referred to an environment variable that set the root directory for your Go workspace. While it is no longer strictly necessary since the introduction of Go Modules in Go 1.11, understanding what it meant is crucial for comprehending Go's evolution.</p>"},{"location":"questions/#what-it-was","title":"What it Was:","text":"<p><code>GOPATH</code> defined the workspace where Go tools looked for:</p> <ol> <li>Source Code (<code>src</code>): Where your Go source files and the source files of external dependencies were located (e.g., <code>$GOPATH/src/github.com/user/project</code>).</li> <li>Compiled Packages (<code>pkg</code>): Where precompiled package objects were stored.</li> <li>Installed Commands (<code>bin</code>): Where executable binaries were placed after running <code>go install</code>.</li> </ol>"},{"location":"questions/#what-it-means-today","title":"What it Means (Today):","text":"<p>Today, the meaning of <code>GOPATH</code> is that of a legacy organizational structure.</p> <ul> <li>For modern projects using Go Modules, the location of the project can be anywhere, and the dependency management is handled by the <code>go.mod</code> file.</li> <li>The only remaining key use of <code>GOPATH</code> is to specify the location of the Go toolchain's binaries (via <code>$GOPATH/bin</code>) and the Global Module Cache (often under <code>$GOPATH/pkg/mod</code>), which is where all downloaded module dependencies are stored globally.</li> </ul>"},{"location":"questions/#how-programming-language-playgrounds-are-made","title":"\ud83c\udfae How Programming Language Playgrounds Are Made","text":"<p>Programming language playgrounds (like the Go Playground) are interactive web environments that let users write, compile, and run code directly in their browser without any local setup.</p> <p>They generally work using these core components:</p> <ol> <li>Frontend (Browser):<ul> <li>An editor (often using libraries like CodeMirror or Monaco) captures the user's code.</li> <li>A JavaScript handler sends the code as a string via HTTP POST request to the backend server.</li> </ul> </li> <li>Backend (Server):<ul> <li>The server receives the code.</li> <li>Sandboxing: This is the most critical security step. The code is executed within an isolated, resource-limited container (like a Docker container or a dedicated virtual machine). This prevents malicious code from accessing the server's file system or consuming excessive resources.</li> <li>Compilation/Interpretation: The language's compiler (e.g., the Go compiler) or interpreter is invoked on the sandboxed code.</li> <li>Execution: The compiled/interpreted code is run within the sandbox.</li> </ul> </li> <li>Result Delivery:<ul> <li>The backend captures the program's output (stdout and stderr).</li> <li>The output (and any compilation errors) is sent back to the browser as a JSON response.</li> </ul> </li> <li>Frontend Display:<ul> <li>The browser receives the JSON and updates the output panel for the user.</li> </ul> </li> </ol>"},{"location":"questions/#go-packages-and-how-they-work","title":"\ud83d\udce6 Go Packages and How They Work","text":""},{"location":"questions/#what-are-go-packages","title":"What are Go Packages?","text":"<p>A Go package is the fundamental way of organizing and reusing code in Go.</p> <ul> <li>Every Go program is made up of packages.</li> <li>A directory containing Go source files (<code>.go</code> files) is treated as a single package.</li> <li>All files in the same directory must declare the same <code>package</code> name at the top.</li> <li>The package named <code>main</code> is special\u2014it defines a standalone executable program, starting with the <code>main()</code> function.</li> </ul>"},{"location":"questions/#how-they-work","title":"How They Work:","text":"Concept Description Encapsulation Items (functions, variables, types) starting with a capital letter (e.g., <code>Add</code>) are exported (public) and visible to other packages. Items starting with a lowercase letter (e.g., <code>calculate</code>) are unexported (private) and only accessible within the package they are defined in. Importing To use code from another package, you must use the <code>import</code> keyword followed by the package's import path (e.g., <code>import \"myproject/calculator\"</code>). Usage Once imported, you access exported functions/variables using the package name prefix and the dot operator (e.g., <code>calculator.Add(5, 3)</code>)."},{"location":"questions/#golang-calculator-using-packages","title":"\ud83d\udee0\ufe0f Golang Calculator Using Packages","text":"<p>Here is a simple Go calculator project structured using packages.</p>"},{"location":"questions/#project-structure","title":"Project Structure:","text":"<pre><code>calculator_app/\n\u251c\u2500\u2500 main.go               // Main executable program (package main)\n\u2514\u2500\u2500 mathops/              // Sub-directory for the package\n    \u251c\u2500\u2500 mathops.go        // Calculator logic (package mathops)\n    \u2514\u2500\u2500 go.mod            // Module file for dependency tracking\n</code></pre>"},{"location":"questions/#1-mathopsmathopsgo-the-package","title":"1. <code>mathops/mathops.go</code> (The Package)","text":"<pre><code>package mathops\n\n// Add adds two integers and returns the result.\n// It is exported (public) because it starts with a capital letter.\nfunc Add(a, b int) int {\n    return a + b\n}\n\n// Subtract subtracts the second integer from the first.\n// It is exported (public) because it starts with a capital letter.\nfunc Subtract(a, b int) int {\n    return a - b\n}\n\n// multiply is a helper function that is NOT exported (private).\n// It cannot be called from main.go.\nfunc multiply(a, b int) int {\n    return a * b\n}\n</code></pre>"},{"location":"questions/#2-maingo-the-executable","title":"2. <code>main.go</code> (The Executable)","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    // Import the package we created. The path is based on the module name.\n    \"calculator_app/mathops\"\n)\n\nfunc main() {\n    a := 10\n    b := 5\n\n    // 1. Use the exported Add function from the mathops package\n    sum := mathops.Add(a, b)\n    fmt.Printf(\"Addition of %d and %d is: %d\\n\", a, b, sum) // Output: 15\n\n    // 2. Use the exported Subtract function\n    diff := mathops.Subtract(a, b)\n    fmt.Printf(\"Subtraction of %d and %d is: %d\\n\", a, b, diff) // Output: 5\n\n    // 3. Attempting to use the unexported 'multiply' function would result in an error:\n    // product := mathops.multiply(a, b) // ERROR: cannot refer to unexported name mathops.multiply\n}\n</code></pre>"},{"location":"questions/#3-setup-and-run","title":"3. Setup and Run:","text":"<pre><code># Initialize the module (crucial for defining the import path)\ncd calculator_app\ngo mod init calculator_app\n\n# Create the mathops directory and files (if you didn't already)\nmkdir mathops\n\n# Run the program\ngo run main.go\n# Output:\n# Addition of 10 and 5 is: 15\n# Subtraction of 10 and 5 is: 5\n</code></pre>"},{"location":"questions/#go-modules-vs-packages","title":"\ud83e\uddf1 Go Modules vs. Packages","text":"<p>Modules and Packages are both organizational units, but they operate at different levels of a project.</p>"},{"location":"questions/#1-package-the-code-unit","title":"1. Package (The Code Unit)","text":"Feature Description Real-World Analogy Scope Code Level - Files that work together (e.g., <code>mathops</code>, <code>database</code>, <code>userhandler</code>). A single chapter in a textbook, containing related topics and exercises. Definition A collection of Go source files in a single directory. Purpose Code organization, encapsulation, and reuse. Key File <code>.go</code> files containing <code>package [name]</code>."},{"location":"questions/#2-module-the-project-unit","title":"2. Module (The Project Unit)","text":"Feature Description Real-World Analogy Scope Project Level - A versioned collection of packages and dependencies. The entire textbook, which has a title, version number, and a list of references/bibliography. Definition A directory containing a <code>go.mod</code> file. Purpose Dependency management and versioning. It defines the required Go version and external dependencies. Key File <code>go.mod</code> (lists dependencies) and <code>go.sum</code> (verifies dependency integrity)."},{"location":"questions/#summary-of-differences","title":"Summary of Differences:","text":"Package Module Defined by <code>package</code> keyword in <code>.go</code> files <code>go.mod</code> file Primary Goal Organize your code Manage dependencies Versioned? No Yes (The module itself is versioned) Contains Functions, types, variables Packages (local and external)"},{"location":"questions/#real-world-example","title":"Real-World Example:","text":"<p>Imagine you are building an e-commerce website called <code>ecom-api</code>.</p> <ul> <li>Module: The entire <code>ecom-api</code> project is one Module. Its <code>go.mod</code> file lists dependencies like the PostgreSQL driver (<code>github.com/lib/pq</code>) and a logging library (<code>go.uber.org/zap</code>).</li> <li>Packages:</li> <li><code>main</code> package: Contains the code that starts the server.</li> <li><code>order</code> package: Handles order creation, updates, and cancellations.</li> <li><code>payment</code> package: Handles communication with the payment gateway.</li> <li><code>user/auth</code> package: Handles login and token generation.</li> </ul> <p>The Module ensures the entire project uses the correct, working versions of external dependencies, while the Packages ensure the code is clean, separated, and reusable within the project.</p> <p>Project idea random number generator and scientific calculator. projects using math.sqrt That's an interesting request! I can certainly provide detailed project ideas for a random number generator and a scientific calculator, focusing on the concepts and structure of the Go projects, including where the <code>math.Sqrt</code> function would be used, all without providing the actual Go code.</p> <p>Here are the project ideas, structured using Go packages and modules.</p>"},{"location":"questions/#project-idea-1-secure-random-number-generator-rng","title":"\ud83d\udca1 Project Idea 1: Secure Random Number Generator (RNG)","text":"<p>This project focuses on providing robust random number generation, which is crucial for simulations, security (cryptography), and unique ID generation.</p>"},{"location":"questions/#goal","title":"\ud83c\udfaf Goal:","text":"<p>Create a Go package that provides various types of high-quality random numbers, leveraging Go's standard library for both fast (pseudo-random) and secure (cryptographically-secure) generation.</p>"},{"location":"questions/#project-structure_1","title":"\ud83d\udce6 Project Structure:","text":"<pre><code>rng_project/\n\u251c\u2500\u2500 main.go             // Uses the generator package\n\u251c\u2500\u2500 generator/          // The core package\n\u2502   \u251c\u2500\u2500 generator.go    // Public functions for RNG\n\u2502   \u2514\u2500\u2500 secure.go       // Logic for cryptographically secure RNG\n\u2514\u2500\u2500 go.mod              // Module file\n</code></pre>"},{"location":"questions/#key-package-functions-generator-package","title":"\u2699\ufe0f Key Package Functions (<code>generator</code> package):","text":"Function Idea Purpose Math Concepts Involved <code>RandomInt(min, max int)</code> Generates a standard, fast pseudo-random integer within a specified range. Modulo arithmetic, seeding. <code>CryptoInt(max int)</code> Generates a cryptographically secure random integer up to <code>max</code>. Entropy, secure hashing. <code>ShuffleSlice[T any](slice []T)</code> Randomly reorders elements in a slice (e.g., shuffling a deck of cards). Fisher-Yates shuffle algorithm. <code>GaussianFloat64()</code> Generates a floating-point number following a Normal (Gaussian) Distribution. Square Root (<code>math.Sqrt</code>) is often used in the Box-Muller transform to convert uniform random variables into Gaussian distributed ones."},{"location":"questions/#mathsqrt-usage-in-rng","title":"\ud83d\udee0\ufe0f <code>math.Sqrt</code> Usage in RNG:","text":"<p>The <code>math.Sqrt</code> function is essential for generating numbers that follow specific non-uniform distributions. In the Gaussian Float function:</p> <ol> <li>Two independent, uniformly distributed random numbers ($U_1$, $U_2$) are generated.</li> <li>The Box-Muller transform requires calculating the square root of a natural logarithm to determine the radial distance from the origin in a 2D plane.</li> <li>The final result uses the output of $\\sqrt{-2 \\ln(U_1)}$ to apply the transformation, making <code>math.Sqrt</code> a core component of this statistical method.</li> </ol>"},{"location":"questions/#project-idea-2-command-line-scientific-calculator","title":"\ud83d\udd22 Project Idea 2: Command-Line Scientific Calculator","text":"<p>This project creates a command-line tool capable of evaluating complex scientific expressions. It would be implemented with clean package separation for logic and user interface.</p>"},{"location":"questions/#goal_1","title":"\ud83c\udfaf Goal:","text":"<p>Build a Go application that accepts a mathematical expression as a string (e.g., <code>\"sqrt(25) + sin(90)\"</code>) and outputs the calculated result.</p>"},{"location":"questions/#project-structure_2","title":"\ud83d\udce6 Project Structure:","text":"<pre><code>sci_calc/\n\u251c\u2500\u2500 main.go              // Handles CLI input/output (package main)\n\u251c\u2500\u2500 parser/              // Handles expression analysis\n\u2502   \u2514\u2500\u2500 parser.go        // Tokenization and parsing logic\n\u2514\u2500\u2500 solver/              // Handles mathematical evaluation\n    \u2514\u2500\u2500 solver.go        // Core math functions (where math.Sqrt lives)\n</code></pre>"},{"location":"questions/#key-package-functions-solver-package","title":"\u2699\ufe0f Key Package Functions (<code>solver</code> package):","text":"Function Idea Purpose Math Concepts Involved <code>Evaluate(expression string) float64</code> The main function that takes the parsed expression and computes the final value. Operator precedence (PEMDAS). <code>ApplySqrt(value float64) float64</code> Calculates the square root of the input value. Square Root (<code>math.Sqrt</code>). <code>ApplyLog(value float64) float64</code> Calculates the natural logarithm of the input. Logarithms, base constants. <code>ApplySin(angle float64) float64</code> Calculates the sine of an angle (handling radians/degrees conversion). Trigonometry, constants ($\\pi$)."},{"location":"questions/#mathsqrt-usage-in-scientific-calculator","title":"\ud83d\udee0\ufe0f <code>math.Sqrt</code> Usage in Scientific Calculator:","text":"<p>The <code>math.Sqrt</code> function would be directly mapped to the user-facing <code>sqrt()</code> operation. Beyond simple input, it's also critical for more complex internal functions:</p> <ol> <li>Direct Calculation: When the <code>parser</code> package identifies the <code>sqrt(X)</code> function call, the <code>solver</code> package uses <code>math.Sqrt(X)</code> to get the result.</li> <li>Hypotenuse/Distance: If you implement a function to calculate the distance between two points ($x_1, y_1$) and ($x_2, y_2$), the formula is $\\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}$. This requires using <code>math.Sqrt</code>.</li> <li>Quadratic Solver: To solve $ax^2 + bx + c = 0$, the quadratic formula requires the square root of the discriminant ($\\sqrt{b^2 - 4ac}$). The <code>solver</code> package would rely on <code>math.Sqrt</code> for this functionality.</li> </ol>"},{"location":"questions/questions/","title":"\ud83e\udde9 BEGINNER QUESTIONS","text":"<p>1. Pointers Basics</p> <ul> <li>What is the difference between <code>*</code> and <code>&amp;</code> in Go?</li> <li>Given the code, what is the output? Explain why.</li> </ul> <pre><code>a := 10\nb := &amp;a\n*b = 20\nfmt.Println(a, *b)\n</code></pre> <ul> <li>Declare an integer variable, create a pointer to it, and modify its value through the pointer.</li> </ul> <p>2. Structs Basics</p> <ul> <li>Define a struct <code>User</code> with fields <code>Name</code> and <code>Age</code>. Create an instance and print the fields.</li> <li>Given a struct, what happens when you assign it to another variable and modify the copy?</li> <li>Initialize a struct using both ordered values and named fields.</li> </ul> <p>3. Arrays Basics</p> <ul> <li>Declare an array of 5 integers. Set the first and last elements, then print the array.</li> <li>How does Go handle uninitialized elements in an array?</li> </ul> <p>4. Slices Basics</p> <ul> <li>Declare a slice of strings with three values. Append two more values and print the slice.</li> <li>Given a slice <code>s := []int{1,2,3,4}</code>, what is the output of <code>s[1:3]</code>?</li> <li>What is the difference between arrays and slices in Go?</li> </ul>"},{"location":"questions/questions/#intermediate-questions","title":"\ud83e\udde9 INTERMEDIATE QUESTIONS","text":"<p>1. Pointers to Structs</p> <ul> <li>Define a struct <code>Account</code> with a field <code>Balance</code>. Write a function <code>Deposit</code> that increases balance via pointer.</li> <li>Explain what happens when you assign a pointer to a struct versus copying the struct.</li> <li>Create two pointers pointing to the same struct. Modify the struct through one pointer. What is visible through the other pointer?</li> </ul> <p>2. Structs and Methods</p> <ul> <li>Write a method <code>IncrementAge</code> for a <code>User</code> struct that increases age by 1. Should you use a pointer receiver or value receiver? Explain.</li> <li>Create a nested struct <code>Employee</code> with an <code>Address</code> struct inside. Write a function that updates the city via pointer.</li> </ul> <p>3. Arrays &amp; Slices</p> <ul> <li>Given an array <code>[5]int{1,2,3,4,5}</code>, create a slice <code>[2:4]</code> and modify it. What happens to the original array?</li> <li>Write a function that takes a slice of integers and doubles every value. Will the original slice be modified? Explain.</li> <li>Explain the difference between <code>len()</code> and <code>cap()</code> for slices with examples.</li> </ul>"},{"location":"questions/questions/#advanced-questions","title":"\ud83e\udde9 ADVANCED QUESTIONS","text":"<p>1. Structs + Pointers + Functions</p> <ul> <li>Implement a <code>Bank</code> struct containing a slice of <code>Account</code> structs. Write a function that transfers money from one account to another using pointers.</li> <li>Explain what happens internally when a slice is passed to a function. Does modifying the slice affect the original?</li> </ul> <p>2. Memory &amp; References</p> <ul> <li>Given the code below, what will it print and why?</li> </ul> <pre><code>type Node struct {\n    Value int\n    Next  *Node\n}\n\nn1 := Node{Value:1}\nn2 := n1\nn2.Next = &amp;Node{Value:2}\n\nfmt.Println(n1.Next, n2.Next)\n</code></pre> <ul> <li>Explain the difference between shallow copy and deep copy with structs containing pointers.</li> </ul> <p>3. Practical Slice Manipulation</p> <ul> <li>Implement a function that removes an element at a given index from a slice of integers without using extra slices.</li> <li>Given a slice of integers, write a function that returns a new slice containing only the even numbers. Do not modify the original slice.</li> </ul> <p>4. Combined Problem (Pointers + Slices + Structs)</p> <ul> <li>Implement a <code>Product</code> struct with <code>Name</code> and <code>Stock</code>.</li> <li>Create a slice of <code>Product</code> structs.</li> <li>Write a function <code>Restock(products []*Product, n int)</code> that increases stock of all products by <code>n</code> using pointers.</li> <li>What would happen if you pass <code>[]Product</code> (not pointers) instead?</li> </ul> <p>5. Big Tech-style Challenge</p> <ul> <li> <p>Design a simple in-memory <code>UserManager</code> with:</p> </li> <li> <p>Slice of <code>User</code> structs</p> </li> <li>Functions: <code>AddUser</code>, <code>UpdateEmail</code>, <code>DeleteUser</code></li> <li> <p>Ensure <code>UpdateEmail</code> modifies the original struct efficiently.</p> </li> <li> <p>Explain why slices of pointers might be preferred over slices of structs in this scenario.</p> </li> </ul>"},{"location":"questions/questions/#maps-in-go-clear-explanation-step-by-step-quizzes-real-uses","title":"Maps in Go \u2014 clear explanation + step-by-step quizzes &amp; real uses","text":"<p>Good \u2014 let\u2019s learn maps. I\u2019ll give a short explanation, show common operations with code, then a set of step-by-step quizzes (beginner \u2192 advanced) you can code and test. I won\u2019t include answers so you can practice.</p>"},{"location":"questions/questions/#what-is-a-map","title":"What is a map?","text":"<p>A map is an unordered collection of key \u2192 value pairs. Keys must be of a comparable type (strings, ints, pointers, structs with comparable fields, etc.). Maps are reference types and grow dynamically.</p> <p>Basic form:</p> <pre><code>var m map[string]int          // nil map, must be initialized before use\nm = make(map[string]int)     // initialize with make\nm[\"apple\"] = 5               // set\nv := m[\"apple\"]              // get (zero value if absent)\nv, ok := m[\"apple\"]          // comma-ok form to check presence\ndelete(m, \"apple\")           // remove key\n</code></pre> <p>Common uses</p> <ul> <li>Frequency counters (word/char counts)</li> <li>Caches and memoization</li> <li>Lookups (user ID \u2192 profile)</li> <li>Indexes (value \u2192 positions)</li> <li>Adjacency lists for graphs</li> </ul>"},{"location":"questions/questions/#quick-reference-examples","title":"Quick reference examples","text":"<p>Create and initialize:</p> <pre><code>m := map[string]int{\n    \"alice\": 30,\n    \"bob\":   25,\n}\n</code></pre> <p>Add / modify / read:</p> <pre><code>m[\"carol\"] = 28\nage := m[\"alice\"]\nage, ok := m[\"dan\"]  // ok == false if \"dan\" not present\n</code></pre> <p>Delete and length:</p> <pre><code>delete(m, \"bob\")\nfmt.Println(len(m))\n</code></pre> <p>Iterate (order not guaranteed):</p> <pre><code>for k, v := range m {\n    fmt.Println(k, v)\n}\n</code></pre> <p>Nested maps:</p> <pre><code>nested := make(map[string]map[string]int)\nnested[\"group1\"] = make(map[string]int)\nnested[\"group1\"][\"x\"] = 1\n</code></pre> <p>Map keys constraints:</p> <ul> <li>Keys must be comparable (<code>==</code> allowed). Slices, maps, and functions cannot be keys.</li> </ul>"},{"location":"questions/questions/#step-by-step-quizzes-no-answers-included","title":"Step-by-step quizzes (no answers included)","text":"<p>Each task includes code skeleton + steps. Run <code>go run</code> / <code>go test</code> to validate your work.</p>"},{"location":"questions/questions/#beginner","title":"Beginner","text":""},{"location":"questions/questions/#quiz-1-basic-creation-access","title":"Quiz 1 \u2014 Basic creation &amp; access","text":"<ol> <li>Create a file <code>quiz1.go</code>.</li> <li>Create and initialize a map <code>ages</code> with entries: <code>\"Alice\": 30</code>, <code>\"Bob\": 25</code>.</li> <li>Print the age of <code>\"Alice\"</code>.</li> <li>Read <code>\"Charlie\"</code> from the map using comma-ok and print whether the key exists.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 1. create and initialize ages\n    // 2. print ages[\"Alice\"]\n    // 3. read ages[\"Charlie\"] with comma-ok and print existence\n}\n</code></pre> <p>Use-case: simple lookup table for user age.</p>"},{"location":"questions/questions/#quiz-2-add-modify-delete","title":"Quiz 2 \u2014 Add / modify / delete","text":"<ol> <li>Start with an empty map <code>inventory := make(map[string]int)</code>.</li> <li>Add <code>\"apple\": 10</code>, <code>\"banana\": 5</code>.</li> <li>Increase apple by 5.</li> <li>Remove <code>\"banana\"</code>.</li> <li>Print final map and its length.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    inventory := make(map[string]int)\n    // steps...\n}\n</code></pre> <p>Use-case: inventory counts in a small store.</p>"},{"location":"questions/questions/#intermediate","title":"Intermediate","text":""},{"location":"questions/questions/#quiz-3-frequency-counter","title":"Quiz 3 \u2014 Frequency counter","text":"<ol> <li>Write a function <code>WordCount(s string) map[string]int</code> that returns counts of words separated by spaces.</li> <li>Test with <code>\"go go gopher go\"</code>.</li> <li>Print top 2 words by count (just iterate and identify).</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc WordCount(s string) map[string]int {\n    // implement\n}\n\nfunc main() {\n    counts := WordCount(\"go go gopher go\")\n    fmt.Println(counts)\n}\n</code></pre> <p>Use-case: text analytics / simple log analysis.</p>"},{"location":"questions/questions/#quiz-4-map-with-struct-values","title":"Quiz 4 \u2014 Map with struct values","text":"<ol> <li>Define <code>type User struct { Name string; Email string }</code>.</li> <li>Create <code>users := make(map[int]User)</code> (map user ID \u2192 User).</li> <li>Add at least two users.</li> <li>Update one user\u2019s email (show how to read-modify-write).</li> <li>Print all users.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype User struct {\n    Name  string\n    Email string\n}\n\nfunc main() {\n    users := make(map[int]User)\n    // steps...\n}\n</code></pre> <p>Use-case: in-memory user store.</p>"},{"location":"questions/questions/#quiz-5-map-of-slices-groups","title":"Quiz 5 \u2014 Map of slices (groups)","text":"<ol> <li>Create <code>groups := make(map[string][]string)</code>.</li> <li>Add members to group <code>\"admins\"</code> and <code>\"devs\"</code>.</li> <li>Append another member to <code>\"devs\"</code>.</li> <li>Iterate and print each group and members.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    groups := make(map[string][]string)\n    // steps...\n}\n</code></pre> <p>Use-case: grouping users by roles.</p>"},{"location":"questions/questions/#advanced","title":"Advanced","text":""},{"location":"questions/questions/#quiz-6-nested-maps-initialization-helper","title":"Quiz 6 \u2014 Nested maps &amp; initialization helper","text":"<ol> <li>Create <code>permissions := make(map[string]map[string]bool)</code> where outer key is username, inner map is permission \u2192 bool.</li> <li>Write helper <code>func SetPerm(m map[string]map[string]bool, user, perm string, value bool)</code> that ensures inner map is initialized before setting.</li> <li>Set a few permissions and print them.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc SetPerm(m map[string]map[string]bool, user, perm string, value bool) {\n    // ensure inner map exists, then set\n}\n\nfunc main() {\n    perms := make(map[string]map[string]bool)\n    // use SetPerm and print results\n}\n</code></pre> <p>Use-case: per-user permission matrix in a service.</p>"},{"location":"questions/questions/#quiz-7-map-concurrency-warning-safe-access","title":"Quiz 7 \u2014 Map concurrency warning &amp; safe access","text":"<ol> <li>Create a read-heavy simulation where multiple goroutines read from a shared map concurrently.</li> <li>Demonstrate that writing to the map concurrently can panic.</li> <li>Refactor to use <code>sync.RWMutex</code> to safely support concurrent reads and occasional writes.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc main() {\n    m := make(map[int]string)\n    // populate m\n\n    // start many goroutines that read m\n\n    // optionally start goroutine that writes to m (show panic without mutex, fix with mutex)\n}\n</code></pre> <p>Use-case: shared in-memory cache in concurrent server.</p>"},{"location":"questions/questions/#quiz-8-graph-adjacency-list","title":"Quiz 8 \u2014 Graph adjacency list","text":"<ol> <li>Use a map to represent an undirected graph: <code>graph := make(map[string][]string)</code>.</li> <li>Implement <code>AddEdge(g map[string][]string, a, b string)</code> that adds an edge both ways.</li> <li>Implement <code>Neighbors(g map[string][]string, node string) []string</code>.</li> <li>Build a small graph, print neighbors of a node, and perform a simple BFS to find if two nodes are connected.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc AddEdge(g map[string][]string, a, b string) {\n    // add both directions\n}\n\nfunc Neighbors(g map[string][]string, node string) []string {\n    return g[node]\n}\n\nfunc main() {\n    g := make(map[string][]string)\n    // build graph, print neighbors, BFS simple connectivity\n}\n</code></pre> <p>Use-case: routing, network topology, recommendation engines.</p>"},{"location":"questions/questions/#quiz-9-map-key-constraints-custom-key","title":"Quiz 9 \u2014 Map key constraints &amp; custom key","text":"<ol> <li>Define <code>type Point struct { X, Y int }</code> and use <code>map[Point]string</code> (color).</li> <li>Insert a few points and read them.</li> <li>Try to use a slice as a key and observe the compiler error \u2014 explain why slices cannot be map keys.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype Point struct { X, Y int }\n\nfunc main() {\n    m := make(map[Point]string)\n    m[Point{1,2}] = \"red\"\n    fmt.Println(m[Point{1,2}])\n    // try map[[]int]string // should not compile\n}\n</code></pre> <p>Use-case: spatial indexing, quick lookups for coordinate-based data.</p>"},{"location":"questions/questions/#quiz-10-large-scale-memoization","title":"Quiz 10 \u2014 Large-scale memoization","text":"<ol> <li>Implement a Fibonacci with memoization using <code>map[int]int</code> to cache results: <code>func Fib(n int, memo map[int]int) int</code>.</li> <li>Measure time with and without memoization for n=40.</li> <li>Discuss memory/time tradeoffs.</li> </ol> <p>Skeleton:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc Fib(n int, memo map[int]int) int {\n    // implement with memo\n}\n\nfunc main() {\n    memo := make(map[int]int)\n    start := time.Now()\n    fmt.Println(Fib(40, memo))\n    fmt.Println(\"Elapsed:\", time.Since(start))\n}\n</code></pre> <p>Use-case: dynamic programming optimization, expensive computation caching.</p>"},{"location":"questions/questions/#extra-tips-gotchas","title":"Extra tips &amp; gotchas","text":"<ul> <li>Maps are reference types: passing to functions gives access to same underlying data.</li> <li>Reading from a nil map returns zero value; writing to a nil map causes panic. Always initialize (<code>make</code>) before write.</li> <li>Maps are not safe for concurrent writes \u2014 use sync.Mutex or sync.RWMutex or <code>sync.Map</code> for concurrent access.</li> <li>Map iteration order is random; do not rely on ordering. If order matters, use a slice of keys and sort it.</li> </ul> <p>If you want, I can:</p> <ul> <li>Provide a small test file for one of the quizzes (e.g., WordCount) so you can run <code>go test</code>.</li> <li>Or produce a cheat sheet listing functions and idioms for maps.</li> </ul> <p>Which would you like next?</p>"}]}