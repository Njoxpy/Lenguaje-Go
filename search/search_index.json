{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Go Language Learning Repository \u00b6 Welcome! This repository is a personal journey through the foundations of the Go programming language, organized for easy exploration. Project Structure \u00b6 Go_Foundations/ 01_Basics/ main.go # Basic syntax and Hello World 02_Constants_and_Types/ main.go # Constants, types, and variables 03_Control_Structures/ main.go # If, for, switch, etc. 04_Functions/ main.go # Functions and parameters 05_Slices_and_Arrays/ main.go # Slices, arrays, and operations 06_Maps/ main.go # Maps and key-value usage 07_Structs/ main.go # Structs and basic OOP projects/ arithmetic.go # Arithmetic operations even.go # Even number checker hello.go # Custom Hello World quiz.go # Simple quiz app vote.go # Voting logic example ... # More small projects and experiments docs/ advice.md # Learning advice and tips roadmap.md # Suggested learning path Key Highlights \u00b6 Go_Foundations/ : Step-by-step folders for each major Go topic, each with a focused main.go . projects/ : Contains practical mini-projects and exercises. This is the best place to review my applied learning and coding style. docs/ : Advice and roadmap for my learning process. How to Run \u00b6 Make sure you have Go installed (recommended: Go 1.20+). To run any example: cd Go_Foundations/01_Basics go run main.go Or for a project: cd Go_Foundations/projects go run quiz.go About \u00b6 Created and maintained by Njoxpy .","title":"Home"},{"location":"#go-language-learning-repository","text":"Welcome! This repository is a personal journey through the foundations of the Go programming language, organized for easy exploration.","title":"Go Language Learning Repository"},{"location":"#project-structure","text":"Go_Foundations/ 01_Basics/ main.go # Basic syntax and Hello World 02_Constants_and_Types/ main.go # Constants, types, and variables 03_Control_Structures/ main.go # If, for, switch, etc. 04_Functions/ main.go # Functions and parameters 05_Slices_and_Arrays/ main.go # Slices, arrays, and operations 06_Maps/ main.go # Maps and key-value usage 07_Structs/ main.go # Structs and basic OOP projects/ arithmetic.go # Arithmetic operations even.go # Even number checker hello.go # Custom Hello World quiz.go # Simple quiz app vote.go # Voting logic example ... # More small projects and experiments docs/ advice.md # Learning advice and tips roadmap.md # Suggested learning path","title":"Project Structure"},{"location":"#key-highlights","text":"Go_Foundations/ : Step-by-step folders for each major Go topic, each with a focused main.go . projects/ : Contains practical mini-projects and exercises. This is the best place to review my applied learning and coding style. docs/ : Advice and roadmap for my learning process.","title":"Key Highlights"},{"location":"#how-to-run","text":"Make sure you have Go installed (recommended: Go 1.20+). To run any example: cd Go_Foundations/01_Basics go run main.go Or for a project: cd Go_Foundations/projects go run quiz.go","title":"How to Run"},{"location":"#about","text":"Created and maintained by Njoxpy .","title":"About"},{"location":"advice/","text":"Golang \u00b6 start with golang tour https://go.dev/tour/welcome/1 for api development use the alex edwards api dev side. NOTE \u00b6 Dedicate 1 hour to 2 hours a day.type everthing. Disable copilot or any AI stuffs unless you want them to teach you or explain further.Here\u2019s a more documentation-style version of your text: Golang Learning Guide \u00b6 Getting Started \u00b6 Complete the Go Tour : https://go.dev/tour/welcome/1 Provides a comprehensive introduction to Go\u2019s basics and core concepts. For API Development , follow Alex Edwards\u2019 Go API development tutorials . Focuses on practical, real-world API building in Go. Recommended Practices \u00b6 Daily Practice: Allocate 1\u20132 hours each day to coding exercises. Manual Typing: Type all code manually to reinforce learning and retention. AI Tools: Disable Copilot or other AI assistants unless used explicitly for explanations or clarifications. python3 - m venv venv # Activate the virtual environment source venv / bin / activate","title":"Advice"},{"location":"advice/#golang","text":"start with golang tour https://go.dev/tour/welcome/1 for api development use the alex edwards api dev side.","title":"Golang"},{"location":"advice/#note","text":"Dedicate 1 hour to 2 hours a day.type everthing. Disable copilot or any AI stuffs unless you want them to teach you or explain further.Here\u2019s a more documentation-style version of your text:","title":"NOTE"},{"location":"advice/#golang-learning-guide","text":"","title":"Golang Learning Guide"},{"location":"advice/#getting-started","text":"Complete the Go Tour : https://go.dev/tour/welcome/1 Provides a comprehensive introduction to Go\u2019s basics and core concepts. For API Development , follow Alex Edwards\u2019 Go API development tutorials . Focuses on practical, real-world API building in Go.","title":"Getting Started"},{"location":"advice/#recommended-practices","text":"Daily Practice: Allocate 1\u20132 hours each day to coding exercises. Manual Typing: Type all code manually to reinforce learning and retention. AI Tools: Disable Copilot or other AI assistants unless used explicitly for explanations or clarifications. python3 - m venv venv # Activate the virtual environment source venv / bin / activate","title":"Recommended Practices"},{"location":"docs/","text":"Basic Types in Go \u00b6 Go provides a set of basic types that are commonly used in programs: Boolean: bool Strings: string Signed integers: int , int8 , int16 , int32 , int64 Unsigned integers: uint , uint8 , uint16 , uint32 , uint64 , uintptr Aliases: byte \u2192 alias for uint8 rune \u2192 alias for int32 (represents a Unicode code point) Floating-point numbers: float32 , float64 Complex numbers: complex64 , complex128 The following example demonstrates variables of various types. It also shows how variable declarations can be grouped together in a block, similar to how imports are grouped. Note: The types int , uint , and uintptr are typically 32 bits on 32-bit systems and 64 bits on 64-bit systems. Use int for general-purpose integers unless you have a specific reason to choose a fixed-size or unsigned integer. package main import ( \"fmt\" \"math/cmplx\" ) var ( ToBe bool = false MaxInt uint64 = 1 << 64 - 1 z complex128 = cmplx . Sqrt ( - 5 + 12i ) ) func main () { fmt . Printf ( \"Type: %T Value: %v\\n\" , ToBe , ToBe ) fmt . Printf ( \"Type: %T Value: %v\\n\" , MaxInt , MaxInt ) fmt . Printf ( \"Type: %T Value: %v\\n\" , z , z ) } Output example: Type : bool Value : false Type : uint64 Value : 18446744073709551615 Type : complex128 Value : ( 2 + 3 i ) Zero Values in Go \u00b6 In Go, variables declared without an explicit initial value are automatically assigned a zero value . The zero value depends on the type of the variable: Numeric types \u2192 0 Boolean type \u2192 false String type \u2192 \"\" (empty string) Example: package main import \"fmt\" func main () { var i int // zero value is 0 var f float64 // zero value is 0 var b bool // zero value is false var s string // zero value is \"\" fmt . Printf ( \"%v %v %v %q\\n\" , i , f , b , s ) } Output: 0 0 false \"\" This feature ensures that all variables in Go always have a well-defined initial value , even if you don\u2019t explicitly assign one.","title":"Docs"},{"location":"docs/#basic-types-in-go","text":"Go provides a set of basic types that are commonly used in programs: Boolean: bool Strings: string Signed integers: int , int8 , int16 , int32 , int64 Unsigned integers: uint , uint8 , uint16 , uint32 , uint64 , uintptr Aliases: byte \u2192 alias for uint8 rune \u2192 alias for int32 (represents a Unicode code point) Floating-point numbers: float32 , float64 Complex numbers: complex64 , complex128 The following example demonstrates variables of various types. It also shows how variable declarations can be grouped together in a block, similar to how imports are grouped. Note: The types int , uint , and uintptr are typically 32 bits on 32-bit systems and 64 bits on 64-bit systems. Use int for general-purpose integers unless you have a specific reason to choose a fixed-size or unsigned integer. package main import ( \"fmt\" \"math/cmplx\" ) var ( ToBe bool = false MaxInt uint64 = 1 << 64 - 1 z complex128 = cmplx . Sqrt ( - 5 + 12i ) ) func main () { fmt . Printf ( \"Type: %T Value: %v\\n\" , ToBe , ToBe ) fmt . Printf ( \"Type: %T Value: %v\\n\" , MaxInt , MaxInt ) fmt . Printf ( \"Type: %T Value: %v\\n\" , z , z ) } Output example: Type : bool Value : false Type : uint64 Value : 18446744073709551615 Type : complex128 Value : ( 2 + 3 i )","title":"Basic Types in Go"},{"location":"docs/#zero-values-in-go","text":"In Go, variables declared without an explicit initial value are automatically assigned a zero value . The zero value depends on the type of the variable: Numeric types \u2192 0 Boolean type \u2192 false String type \u2192 \"\" (empty string) Example: package main import \"fmt\" func main () { var i int // zero value is 0 var f float64 // zero value is 0 var b bool // zero value is false var s string // zero value is \"\" fmt . Printf ( \"%v %v %v %q\\n\" , i , f , b , s ) } Output: 0 0 false \"\" This feature ensures that all variables in Go always have a well-defined initial value , even if you don\u2019t explicitly assign one.","title":"Zero Values in Go"},{"location":"roadmap/","text":"\ud83d\uddd3\ufe0f OVERVIEW \u00b6 Goal: Master Go fundamentals and backend essentials in 3 weeks Resources: Tour of Go , Go docs, Go Playground, VS Code or GoLand Tools: Go 1.22+, Git, Postman (for backend testing later) Style: Learn \u2192 Practice \u2192 Build mini-project \ud83e\udded WEEK 1 \u2013 Foundation & Core Syntax \u00b6 Focus: Understand Go basics, variables, flow control, and syntax fluency. \ud83d\udcd8 Day 1\u20132: Welcome & Basics (Tour Section 1) \u00b6 Do: Tour Part 1 (5 parts) Learn: Hello, World Go Playground & setup locally How Go runs programs Practice: Write a \u201cHello\u201d program printing your name, date, and favorite language. Run it both online and locally. \ud83d\udcd8 Day 3\u20135: Packages, Variables, Functions (17 parts) \u00b6 Learn: Importing packages Exported names Variables, constants, and short declarations Functions and multiple return values Practice: Write small functions that calculate BMI, area of circle, etc. Experiment with package-level vs function-level variables. \ud83d\udcd8 Day 6\u20137 (Weekend Deep Dive) \u00b6 Review all lessons with custom notes. Mini-Project #1: CLI Utility Build a small Go command-line tool: go run greet.go --name=\"Njox\" \u2192 Outputs \u201cHello Njox! Welcome to Go!\u201d Add flags and simple error handling. \ud83e\udded WEEK 2 \u2013 Data Types & Control Logic \u00b6 Focus: Strengthen logic skills and learn Go\u2019s composite types. \ud83d\udcd8 Day 8\u20139: Flow Control (14 parts) \u00b6 Learn: for loops if/else, switch, defer Practice: Implement a fizzbuzz program with for and switch Try multiple defer statements and observe execution order \ud83d\udcd8 Day 10\u201313: More Types (27 parts) \u00b6 Learn: Pointers Structs, arrays, slices, maps Range, append, make Practice: Build a \u201cStudent Record\u201d app with struct + slice of structs Write functions to add, list, and search students \ud83d\udcd8 Day 14\u201315 (Weekend Project) \u00b6 Mini-Project #2: JSON Data API (local) Use structs and slices to hold mock data Use encoding/json to encode/decode data Expose simple endpoints via net/http GET /students POST /students Use Postman or curl to test \ud83e\udded WEEK 3 \u2013 OOP, Concurrency & Backend Integration \u00b6 Focus: Advanced features \u2014 methods, interfaces, generics, and goroutines. \ud83d\udcd8 Day 16\u201318: Methods & Interfaces (26 parts) \u00b6 Learn: Methods on structs Interfaces and polymorphism Type assertions Practice: Create a simple interface like: go type Notifier interface { Notify(msg string) } Implement for EmailNotifier and SMSNotifier . \ud83d\udcd8 Day 19: Generics (3 parts) \u00b6 Learn: Type parameters and constraints. Practice: Build a generic Sum() or Filter() function for integers and floats. \ud83d\udcd8 Day 20\u201321: Concurrency (11 parts) \u00b6 Learn: Goroutines Channels and buffered channels Select statement Practice: Write a program that fetches URLs concurrently and prints response times. \ud83d\udcd8 Day 22\u201323 (Weekend Capstone) \u00b6 Final Project: Mini Go REST API Backend Use Gin or Fiber Endpoints: GET /tasks \u2192 list tasks POST /tasks \u2192 add task DELETE /tasks/:id \u2192 delete task Add concurrency feature: log each request in a separate goroutine Add JSON storage (no database yet) \ud83c\udf93 Final Review (Day 24\u201321 overlap optional) \u00b6 Revisit difficult concepts (interfaces, concurrency) Push all projects to GitHub Try running your API as a service using go run main.go Optional: add SQLite or MongoDB to API \ud83d\udca1 Tips \u00b6 Use go fmt , go run , and go test frequently. Read code from Go by Example . Write at least 20\u201330 lines of Go code daily. On weekends, reflect on what you\u2019ve built.","title":"Roadmap"},{"location":"roadmap/#overview","text":"Goal: Master Go fundamentals and backend essentials in 3 weeks Resources: Tour of Go , Go docs, Go Playground, VS Code or GoLand Tools: Go 1.22+, Git, Postman (for backend testing later) Style: Learn \u2192 Practice \u2192 Build mini-project","title":"\ud83d\uddd3\ufe0f OVERVIEW"},{"location":"roadmap/#week-1-foundation-core-syntax","text":"Focus: Understand Go basics, variables, flow control, and syntax fluency.","title":"\ud83e\udded WEEK 1 \u2013 Foundation &amp; Core Syntax"},{"location":"roadmap/#day-12-welcome-basics-tour-section-1","text":"Do: Tour Part 1 (5 parts) Learn: Hello, World Go Playground & setup locally How Go runs programs Practice: Write a \u201cHello\u201d program printing your name, date, and favorite language. Run it both online and locally.","title":"\ud83d\udcd8 Day 1\u20132: Welcome &amp; Basics (Tour Section 1)"},{"location":"roadmap/#day-35-packages-variables-functions-17-parts","text":"Learn: Importing packages Exported names Variables, constants, and short declarations Functions and multiple return values Practice: Write small functions that calculate BMI, area of circle, etc. Experiment with package-level vs function-level variables.","title":"\ud83d\udcd8 Day 3\u20135: Packages, Variables, Functions (17 parts)"},{"location":"roadmap/#day-67-weekend-deep-dive","text":"Review all lessons with custom notes. Mini-Project #1: CLI Utility Build a small Go command-line tool: go run greet.go --name=\"Njox\" \u2192 Outputs \u201cHello Njox! Welcome to Go!\u201d Add flags and simple error handling.","title":"\ud83d\udcd8 Day 6\u20137 (Weekend Deep Dive)"},{"location":"roadmap/#week-2-data-types-control-logic","text":"Focus: Strengthen logic skills and learn Go\u2019s composite types.","title":"\ud83e\udded WEEK 2 \u2013 Data Types &amp; Control Logic"},{"location":"roadmap/#day-89-flow-control-14-parts","text":"Learn: for loops if/else, switch, defer Practice: Implement a fizzbuzz program with for and switch Try multiple defer statements and observe execution order","title":"\ud83d\udcd8 Day 8\u20139: Flow Control (14 parts)"},{"location":"roadmap/#day-1013-more-types-27-parts","text":"Learn: Pointers Structs, arrays, slices, maps Range, append, make Practice: Build a \u201cStudent Record\u201d app with struct + slice of structs Write functions to add, list, and search students","title":"\ud83d\udcd8 Day 10\u201313: More Types (27 parts)"},{"location":"roadmap/#day-1415-weekend-project","text":"Mini-Project #2: JSON Data API (local) Use structs and slices to hold mock data Use encoding/json to encode/decode data Expose simple endpoints via net/http GET /students POST /students Use Postman or curl to test","title":"\ud83d\udcd8 Day 14\u201315 (Weekend Project)"},{"location":"roadmap/#week-3-oop-concurrency-backend-integration","text":"Focus: Advanced features \u2014 methods, interfaces, generics, and goroutines.","title":"\ud83e\udded WEEK 3 \u2013 OOP, Concurrency &amp; Backend Integration"},{"location":"roadmap/#day-1618-methods-interfaces-26-parts","text":"Learn: Methods on structs Interfaces and polymorphism Type assertions Practice: Create a simple interface like: go type Notifier interface { Notify(msg string) } Implement for EmailNotifier and SMSNotifier .","title":"\ud83d\udcd8 Day 16\u201318: Methods &amp; Interfaces (26 parts)"},{"location":"roadmap/#day-19-generics-3-parts","text":"Learn: Type parameters and constraints. Practice: Build a generic Sum() or Filter() function for integers and floats.","title":"\ud83d\udcd8 Day 19: Generics (3 parts)"},{"location":"roadmap/#day-2021-concurrency-11-parts","text":"Learn: Goroutines Channels and buffered channels Select statement Practice: Write a program that fetches URLs concurrently and prints response times.","title":"\ud83d\udcd8 Day 20\u201321: Concurrency (11 parts)"},{"location":"roadmap/#day-2223-weekend-capstone","text":"Final Project: Mini Go REST API Backend Use Gin or Fiber Endpoints: GET /tasks \u2192 list tasks POST /tasks \u2192 add task DELETE /tasks/:id \u2192 delete task Add concurrency feature: log each request in a separate goroutine Add JSON storage (no database yet)","title":"\ud83d\udcd8 Day 22\u201323 (Weekend Capstone)"},{"location":"roadmap/#final-review-day-2421-overlap-optional","text":"Revisit difficult concepts (interfaces, concurrency) Push all projects to GitHub Try running your API as a service using go run main.go Optional: add SQLite or MongoDB to API","title":"\ud83c\udf93 Final Review (Day 24\u201321 overlap optional)"},{"location":"roadmap/#tips","text":"Use go fmt , go run , and go test frequently. Read code from Go by Example . Write at least 20\u201330 lines of Go code daily. On weekends, reflect on what you\u2019ve built.","title":"\ud83d\udca1 Tips"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/","text":"Packages in Go \u00b6 Every Go program is composed of packages . Execution always begins in the main package. This example uses the packages with import paths \"fmt\" and \"math/rand\" . By convention, the package name matches the last element of its import path. For example, files in the \"math/rand\" package start with the declaration: package rand Example: \u00b6 package main import ( \"fmt\" \"math/rand\" ) func main () { fmt . Println ( \"My favorite number is\" , rand . Intn ( 10 )) } Imports \u00b6 In Go, imports can be grouped into a factored import statement , enclosed in parentheses. This is the preferred style for readability and organization. Example (factored import): \u00b6 package main import ( \"fmt\" \"math\" ) func main () { fmt . Printf ( \"Now you have %g problems.\\n\" , math . Sqrt ( 7 )) } Output: Now you have 2.6457513110645907 problems. Program exited. Alternatively, you can use multiple single-line import statements, though it\u2019s less common: import \"fmt\" import \"math\" Exported Names \u00b6 In Go, a name is exported if it begins with a capital letter . For example: Pizza \u2014 exported Pi \u2014 exported from the math package pizza and pi \u2014 not exported (private to the package) When you import a package, you can access only its exported names . Unexported names (those starting with a lowercase letter) are not accessible from outside the package. Example (with error): \u00b6 package main import ( \"fmt\" \"math\" ) func main () { fmt . Println ( math . pi ) // Error: cannot refer to unexported name math.pi } Fixed version: \u00b6 package main import ( \"fmt\" \"math\" ) func main () { fmt . Println ( math . Pi ) // Works correctly } Go Language Basics \u00b6 Functions \u00b6 A function in Go can take zero or more arguments. In the following example, the add function takes two parameters of type int . Notice that the type is written after the variable name. package main import \"fmt\" func add ( x int , y int ) int { return x + y } func main () { fmt . Println ( add ( 42 , 13 )) } Functions (continued) \u00b6 When two or more consecutive parameters share a type, you can omit the type from all but the last. For example, instead of writing: x int , y int you can write: x , y int package main import \"fmt\" func add ( x , y int ) int { return x + y } func main () { fmt . Println ( add ( 42 , 13 )) } Multiple Results \u00b6 A function can return multiple values . Here, the swap function returns two strings. package main import \"fmt\" func swap ( x , y string ) ( string , string ) { return y , x } func main () { a , b := swap ( \"hello\" , \"world\" ) fmt . Println ( a , b ) } Named Return Values \u00b6 Go allows you to name return values. These are treated as variables defined at the top of the function. A naked return statement (without arguments) returns these named values automatically. Note: Naked returns should be used only in short, simple functions to preserve readability. package main import \"fmt\" func split ( sum int ) ( x , y int ) { x = sum * 4 / 9 y = sum - x return } func main () { fmt . Println ( split ( 17 )) } Variables \u00b6 The var statement declares a list of variables, with the type coming last . A var declaration can appear at both package and function level. package main import \"fmt\" var c , python , java bool func main () { var i int fmt . Println ( i , c , python , java ) } Variables with Initializers \u00b6 A var declaration can include initializers . If an initializer is provided, the type can be omitted since it will be inferred from the value. package main import \"fmt\" var i , j int = 1 , 2 func main () { var c , python , java = true , false , \"no!\" fmt . Println ( i , j , c , python , java ) } Short Variable Declarations \u00b6 Inside a function, you can use the shorthand := to declare and initialize variables. Outside functions, := cannot be used because all statements must start with a keyword (like var or func ). package main import \"fmt\" func main () { var i , j int = 1 , 2 k := 3 c , python , java := true , false , \"no!\" fmt . Println ( i , j , k , c , python , java ) } Basic Types \u00b6 Go\u2019s basic data types include: bool string Numeric types: Signed integers: int , int8 , int16 , int32 , int64 Unsigned integers: uint , uint8 , uint16 , uint32 , uint64 , uintptr Aliases: byte (for uint8 ), rune (for int32 , representing Unicode code points) Floating point: float32 , float64 Complex numbers: complex64 , complex128 Typically, int , uint , and uintptr are 32 bits on 32-bit systems and 64 bits on 64-bit systems. Use int unless you have a specific reason to choose another type. package main import ( \"fmt\" \"math/cmplx\" ) var ( ToBe bool = false MaxInt uint64 = 1 << 64 - 1 z complex128 = cmplx . Sqrt ( - 5 + 12i ) ) func main () { fmt . Printf ( \"Type: %T Value: %v\\n\" , ToBe , ToBe ) fmt . Printf ( \"Type: %T Value: %v\\n\" , MaxInt , MaxInt ) fmt . Printf ( \"Type: %T Value: %v\\n\" , z , z ) } Zero Values \u00b6 Variables declared without an explicit initializer are assigned their zero value : 0 for numeric types false for booleans \"\" (empty string) for strings package main import \"fmt\" func main () { var i int var f float64 var b bool var s string fmt . Printf ( \"%v %v %v %q\\n\" , i , f , b , s ) } Type Conversions \u00b6 Use T(v) to convert the value v to type T . Example: var i int = 42 var f float64 = float64 ( i ) var u uint = uint ( f ) Or, more simply: i := 42 f := float64 ( i ) u := uint ( f ) Unlike C, Go requires explicit type conversions . package main import ( \"fmt\" \"math\" ) func main () { var x , y int = 3 , 4 var f float64 = math . Sqrt ( float64 ( x * x + y * y )) var z uint = uint ( f ) fmt . Println ( x , y , z ) } Type Inference \u00b6 If you declare a variable without specifying its type (using := or var = ), Go infers the type from the value. When the value has a type, the new variable takes that type. When the value is an untyped constant , Go assigns a suitable default type. Examples: var i int j := i // j is an int i := 42 // int f := 3.142 // float64 g := 0.867 + 0.5i // complex128 package main import \"fmt\" func main () { v := 42 // change me! fmt . Printf ( \"v is of type %T\\n\" , v ) } Constants \u00b6 Constants are declared like variables, but with the const keyword. They can be character, string, boolean, or numeric values. You cannot use := for constants. package main import \"fmt\" const Pi = 3.14 func main () { const World = \"\u4e16\u754c\" fmt . Println ( \"Hello\" , World ) fmt . Println ( \"Happy\" , Pi , \"Day\" ) const Truth = true fmt . Println ( \"Go rules?\" , Truth ) } Numeric Constants \u00b6 Numeric constants are high-precision values. An untyped constant takes on the type required by its context. package main import \"fmt\" const ( // Create a huge number by shifting 1 left 100 places (1 followed by 100 zeroes) Big = 1 << 100 // Shift it right again by 99, resulting in 1<<1 or 2 Small = Big >> 99 ) func needInt ( x int ) int { return x * 10 + 1 } func needFloat ( x float64 ) float64 { return x * 0.1 } func main () { fmt . Println ( needInt ( Small )) fmt . Println ( needFloat ( Small )) fmt . Println ( needFloat ( Big )) } \ud83c\udf89 Congratulations! \u00b6 You\u2019ve completed this Go basics module. You can now proceed to the next lesson or review previous ones to strengthen your understanding.","title":"Overview"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#packages-in-go","text":"Every Go program is composed of packages . Execution always begins in the main package. This example uses the packages with import paths \"fmt\" and \"math/rand\" . By convention, the package name matches the last element of its import path. For example, files in the \"math/rand\" package start with the declaration: package rand","title":"Packages in Go"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#example","text":"package main import ( \"fmt\" \"math/rand\" ) func main () { fmt . Println ( \"My favorite number is\" , rand . Intn ( 10 )) }","title":"Example:"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#imports","text":"In Go, imports can be grouped into a factored import statement , enclosed in parentheses. This is the preferred style for readability and organization.","title":"Imports"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#example-factored-import","text":"package main import ( \"fmt\" \"math\" ) func main () { fmt . Printf ( \"Now you have %g problems.\\n\" , math . Sqrt ( 7 )) } Output: Now you have 2.6457513110645907 problems. Program exited. Alternatively, you can use multiple single-line import statements, though it\u2019s less common: import \"fmt\" import \"math\"","title":"Example (factored import):"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#exported-names","text":"In Go, a name is exported if it begins with a capital letter . For example: Pizza \u2014 exported Pi \u2014 exported from the math package pizza and pi \u2014 not exported (private to the package) When you import a package, you can access only its exported names . Unexported names (those starting with a lowercase letter) are not accessible from outside the package.","title":"Exported Names"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#example-with-error","text":"package main import ( \"fmt\" \"math\" ) func main () { fmt . Println ( math . pi ) // Error: cannot refer to unexported name math.pi }","title":"Example (with error):"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#fixed-version","text":"package main import ( \"fmt\" \"math\" ) func main () { fmt . Println ( math . Pi ) // Works correctly }","title":"Fixed version:"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#go-language-basics","text":"","title":"Go Language Basics"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#functions","text":"A function in Go can take zero or more arguments. In the following example, the add function takes two parameters of type int . Notice that the type is written after the variable name. package main import \"fmt\" func add ( x int , y int ) int { return x + y } func main () { fmt . Println ( add ( 42 , 13 )) }","title":"Functions"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#functions-continued","text":"When two or more consecutive parameters share a type, you can omit the type from all but the last. For example, instead of writing: x int , y int you can write: x , y int package main import \"fmt\" func add ( x , y int ) int { return x + y } func main () { fmt . Println ( add ( 42 , 13 )) }","title":"Functions (continued)"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#multiple-results","text":"A function can return multiple values . Here, the swap function returns two strings. package main import \"fmt\" func swap ( x , y string ) ( string , string ) { return y , x } func main () { a , b := swap ( \"hello\" , \"world\" ) fmt . Println ( a , b ) }","title":"Multiple Results"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#named-return-values","text":"Go allows you to name return values. These are treated as variables defined at the top of the function. A naked return statement (without arguments) returns these named values automatically. Note: Naked returns should be used only in short, simple functions to preserve readability. package main import \"fmt\" func split ( sum int ) ( x , y int ) { x = sum * 4 / 9 y = sum - x return } func main () { fmt . Println ( split ( 17 )) }","title":"Named Return Values"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#variables","text":"The var statement declares a list of variables, with the type coming last . A var declaration can appear at both package and function level. package main import \"fmt\" var c , python , java bool func main () { var i int fmt . Println ( i , c , python , java ) }","title":"Variables"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#variables-with-initializers","text":"A var declaration can include initializers . If an initializer is provided, the type can be omitted since it will be inferred from the value. package main import \"fmt\" var i , j int = 1 , 2 func main () { var c , python , java = true , false , \"no!\" fmt . Println ( i , j , c , python , java ) }","title":"Variables with Initializers"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#short-variable-declarations","text":"Inside a function, you can use the shorthand := to declare and initialize variables. Outside functions, := cannot be used because all statements must start with a keyword (like var or func ). package main import \"fmt\" func main () { var i , j int = 1 , 2 k := 3 c , python , java := true , false , \"no!\" fmt . Println ( i , j , k , c , python , java ) }","title":"Short Variable Declarations"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#basic-types","text":"Go\u2019s basic data types include: bool string Numeric types: Signed integers: int , int8 , int16 , int32 , int64 Unsigned integers: uint , uint8 , uint16 , uint32 , uint64 , uintptr Aliases: byte (for uint8 ), rune (for int32 , representing Unicode code points) Floating point: float32 , float64 Complex numbers: complex64 , complex128 Typically, int , uint , and uintptr are 32 bits on 32-bit systems and 64 bits on 64-bit systems. Use int unless you have a specific reason to choose another type. package main import ( \"fmt\" \"math/cmplx\" ) var ( ToBe bool = false MaxInt uint64 = 1 << 64 - 1 z complex128 = cmplx . Sqrt ( - 5 + 12i ) ) func main () { fmt . Printf ( \"Type: %T Value: %v\\n\" , ToBe , ToBe ) fmt . Printf ( \"Type: %T Value: %v\\n\" , MaxInt , MaxInt ) fmt . Printf ( \"Type: %T Value: %v\\n\" , z , z ) }","title":"Basic Types"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#zero-values","text":"Variables declared without an explicit initializer are assigned their zero value : 0 for numeric types false for booleans \"\" (empty string) for strings package main import \"fmt\" func main () { var i int var f float64 var b bool var s string fmt . Printf ( \"%v %v %v %q\\n\" , i , f , b , s ) }","title":"Zero Values"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#type-conversions","text":"Use T(v) to convert the value v to type T . Example: var i int = 42 var f float64 = float64 ( i ) var u uint = uint ( f ) Or, more simply: i := 42 f := float64 ( i ) u := uint ( f ) Unlike C, Go requires explicit type conversions . package main import ( \"fmt\" \"math\" ) func main () { var x , y int = 3 , 4 var f float64 = math . Sqrt ( float64 ( x * x + y * y )) var z uint = uint ( f ) fmt . Println ( x , y , z ) }","title":"Type Conversions"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#type-inference","text":"If you declare a variable without specifying its type (using := or var = ), Go infers the type from the value. When the value has a type, the new variable takes that type. When the value is an untyped constant , Go assigns a suitable default type. Examples: var i int j := i // j is an int i := 42 // int f := 3.142 // float64 g := 0.867 + 0.5i // complex128 package main import \"fmt\" func main () { v := 42 // change me! fmt . Printf ( \"v is of type %T\\n\" , v ) }","title":"Type Inference"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#constants","text":"Constants are declared like variables, but with the const keyword. They can be character, string, boolean, or numeric values. You cannot use := for constants. package main import \"fmt\" const Pi = 3.14 func main () { const World = \"\u4e16\u754c\" fmt . Println ( \"Hello\" , World ) fmt . Println ( \"Happy\" , Pi , \"Day\" ) const Truth = true fmt . Println ( \"Go rules?\" , Truth ) }","title":"Constants"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#numeric-constants","text":"Numeric constants are high-precision values. An untyped constant takes on the type required by its context. package main import \"fmt\" const ( // Create a huge number by shifting 1 left 100 places (1 followed by 100 zeroes) Big = 1 << 100 // Shift it right again by 99, resulting in 1<<1 or 2 Small = Big >> 99 ) func needInt ( x int ) int { return x * 10 + 1 } func needFloat ( x float64 ) float64 { return x * 0.1 } func main () { fmt . Println ( needInt ( Small )) fmt . Println ( needFloat ( Small )) fmt . Println ( needFloat ( Big )) }","title":"Numeric Constants"},{"location":"Packages%2C%20Variables%2C%20Functions%20%2817%20parts%29/#congratulations","text":"You\u2019ve completed this Go basics module. You can now proceed to the next lesson or review previous ones to strengthen your understanding.","title":"\ud83c\udf89 Congratulations!"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/","text":"Hello, \u4e16\u754c \u00b6 Welcome to the Go Programming Language Tour \u2014 an interactive guide designed to help you learn Go step by step. Navigating the Tour \u00b6 The tour is divided into several modules. You can access them by clicking \u201cA Tour of Go\u201d at the top-left of the page. To view the table of contents at any time, click the menu icon in the top-right corner. Each module contains a series of slides and hands-on exercises . Use the navigation options below to move through the tour: Previous or PageUp \u2192 Go to the previous page Next or PageDown \u2192 Move to the next page Running and Editing Code \u00b6 The tour is interactive \u2014 try it now! Click Run (or press Shift + Enter ) to compile and execute the program on a remote server. The output will appear directly below the code editor. Each example demonstrates a specific feature or concept in Go. These programs are designed as starting points for your own experimentation \u2014 feel free to edit the code and run it again . You can also: Click Format (shortcut: Ctrl + Enter ) to format your code using the gofmt tool. Toggle syntax highlighting by clicking the Syntax button. When you\u2019re ready to continue, click the right arrow below or press PageDown . Example Program \u00b6 package main import \"fmt\" func main () { fmt . Println ( \"Hello, \u4e16\u754c\" ) } Go in Your Language \u00b6 The tour is available in multiple languages: Portugu\u00eas do Brasil Catal\u00e0 \u4e2d\u6587\uff08\u7b80\u4f53\uff09 \u010cesky Bahasa Indonesia \u65e5\u672c\u8a9e Polski Espa\u00f1ol \u0e20\u0e32\u0e29\u0e32\u0e44\u0e17\u0e22 \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u043e\u044e Click Next or press PageDown to continue. Go Offline (Optional) \u00b6 You can also take this tour offline . The offline version runs locally on your computer and doesn\u2019t require internet access. To set it up: Install Go on your system. Run the following command: bash go install golang.org/x/website/tour@latest This installs the tour binary in your GOPATH/bin directory. Then, launch the tour program to open a browser window with your local version of the tour. (You can, of course, continue using this online version instead.) The Go Playground \u00b6 This tour is powered by the Go Playground , a web service hosted on golang.org . Here\u2019s how it works: The Playground receives your Go program, compiles, links, and runs it securely inside a sandbox. It then returns the output to your browser. Playground Limitations: \u00b6 The time inside the playground always starts at 2009-11-10 23:00:00 UTC \u2014 a fixed reference that helps ensure consistent program output. Programs have execution time , CPU , and memory limits . Programs cannot access external network hosts . The Playground always uses the latest stable release of Go. To learn more, read Inside the Go Playground . Example \u00b6 package main import ( \"fmt\" \"time\" ) func main () { fmt . Println ( \"Welcome to the playground!\" ) fmt . Println ( \"The time is\" , time . Now ()) } Congratulations \u00b6 You\u2019ve completed the first module of the Go Tour! Click A Tour of Go at the top to explore more topics, or proceed directly to the next lesson to continue your journey.","title":"Overview"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#hello","text":"Welcome to the Go Programming Language Tour \u2014 an interactive guide designed to help you learn Go step by step.","title":"Hello, \u4e16\u754c"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#navigating-the-tour","text":"The tour is divided into several modules. You can access them by clicking \u201cA Tour of Go\u201d at the top-left of the page. To view the table of contents at any time, click the menu icon in the top-right corner. Each module contains a series of slides and hands-on exercises . Use the navigation options below to move through the tour: Previous or PageUp \u2192 Go to the previous page Next or PageDown \u2192 Move to the next page","title":"Navigating the Tour"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#running-and-editing-code","text":"The tour is interactive \u2014 try it now! Click Run (or press Shift + Enter ) to compile and execute the program on a remote server. The output will appear directly below the code editor. Each example demonstrates a specific feature or concept in Go. These programs are designed as starting points for your own experimentation \u2014 feel free to edit the code and run it again . You can also: Click Format (shortcut: Ctrl + Enter ) to format your code using the gofmt tool. Toggle syntax highlighting by clicking the Syntax button. When you\u2019re ready to continue, click the right arrow below or press PageDown .","title":"Running and Editing Code"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#example-program","text":"package main import \"fmt\" func main () { fmt . Println ( \"Hello, \u4e16\u754c\" ) }","title":"Example Program"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#go-in-your-language","text":"The tour is available in multiple languages: Portugu\u00eas do Brasil Catal\u00e0 \u4e2d\u6587\uff08\u7b80\u4f53\uff09 \u010cesky Bahasa Indonesia \u65e5\u672c\u8a9e Polski Espa\u00f1ol \u0e20\u0e32\u0e29\u0e32\u0e44\u0e17\u0e22 \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u043e\u044e Click Next or press PageDown to continue.","title":"Go in Your Language"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#go-offline-optional","text":"You can also take this tour offline . The offline version runs locally on your computer and doesn\u2019t require internet access. To set it up: Install Go on your system. Run the following command: bash go install golang.org/x/website/tour@latest This installs the tour binary in your GOPATH/bin directory. Then, launch the tour program to open a browser window with your local version of the tour. (You can, of course, continue using this online version instead.)","title":"Go Offline (Optional)"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#the-go-playground","text":"This tour is powered by the Go Playground , a web service hosted on golang.org . Here\u2019s how it works: The Playground receives your Go program, compiles, links, and runs it securely inside a sandbox. It then returns the output to your browser.","title":"The Go Playground"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#playground-limitations","text":"The time inside the playground always starts at 2009-11-10 23:00:00 UTC \u2014 a fixed reference that helps ensure consistent program output. Programs have execution time , CPU , and memory limits . Programs cannot access external network hosts . The Playground always uses the latest stable release of Go. To learn more, read Inside the Go Playground .","title":"Playground Limitations:"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#example","text":"package main import ( \"fmt\" \"time\" ) func main () { fmt . Println ( \"Welcome to the playground!\" ) fmt . Println ( \"The time is\" , time . Now ()) }","title":"Example"},{"location":"Welcome%20%26%20Basics%20%28Tour%20Section%201%29/#congratulations","text":"You\u2019ve completed the first module of the Go Tour! Click A Tour of Go at the top to explore more topics, or proceed directly to the next lesson to continue your journey.","title":"Congratulations"},{"location":"controlflowstatements/","text":"For Loops in Go \u00b6 Go has only one looping construct : the for loop. The basic for loop consists of three components separated by semicolons: Initialization statement \u2013 executed before the first iteration Condition expression \u2013 evaluated before every iteration Post statement \u2013 executed at the end of each iteration How it Works \u00b6 The init statement is commonly a short variable declaration. Variables declared here are visible only within the scope of the for loop . The loop continues to execute as long as the condition is true . Once the condition evaluates to false , the loop stops. Unlike C, Java, or JavaScript: There are no parentheses around the components. The curly braces {} are mandatory , even for single-line loops. Example \u00b6 package main import \"fmt\" func main () { sum := 0 for i := 0 ; i < 10 ; i ++ { sum += i } fmt . Println ( sum ) } Explanation: i := 0 initializes the counter. The loop runs while i < 10 . After each iteration, i++ increments i by 1. The loop accumulates the sum of numbers from 0 to 9. Output: 45 For (continued) \u00b6 In Go, the init and post statements in a for loop are optional . You can omit one or both, depending on the logic you need. Example \u00b6 package main import \"fmt\" func main () { sum := 1 for ; sum < 10 ; { sum += sum } fmt . Println ( sum ) } Explanation \u00b6 The init and post sections are left empty. Only the condition ( sum < 10 ) remains between the semicolons. This is perfectly valid Go syntax and works just like a while loop in other languages. The above example doubles the value of sum until it is no longer less than 10. Output \u00b6 16 Tip \u00b6 If both the init and post statements are omitted, the semicolons themselves can also be removed \u2014 turning it into Go\u2019s while-style loop: for sum < 10 { sum += sum } For (continued) \u00b6 The init and post statements in a Go for loop are optional . If you omit them, the for loop still works \u2014 it simply becomes more flexible, resembling a while loop in other languages. Example \u00b6 package main import \"fmt\" func main () { sum := 1 for ; sum < 10 ; { sum += sum } fmt . Println ( sum ) } Explanation \u00b6 The init and post statements are left empty ( ; marks their positions). This means: There is no initialization before the loop starts. There is no automatic update after each iteration. The loop runs as long as the condition sum < 10 is true . Here\u2019s what happens step by step: Step Value of sum Condition ( sum < 10 ) Action 1 1 true sum += sum \u2192 2 2 2 true sum += sum \u2192 4 3 4 true sum += sum \u2192 8 4 8 true sum += sum \u2192 16 5 16 false Loop ends Output \u00b6 16 Key Insight \u00b6 When you omit both the init and post parts, the for loop in Go acts like a while loop in other languages. Equivalent while-style syntax in pseudocode: for sum < 10 { sum += sum } This demonstrates Go\u2019s flexibility \u2014 you can use for in multiple forms, including the traditional C-style loop or simplified while-like loops. For as Go's \"While\" \u00b6 In Go, there is no separate while loop . You can use a for loop without semicolons to achieve the same behavior. This makes the for loop Go\u2019s equivalent of while in other languages like C or Java. Example \u00b6 package main import \"fmt\" func main () { sum := 1 for sum < 1000 { sum += sum } fmt . Println ( sum ) } Explanation \u00b6 The condition sum < 1000 is checked before each iteration. There are no init or post statements ; the semicolons are omitted. The loop continues as long as the condition is true . Each iteration doubles the value of sum . Output \u00b6 1024 Key Insight \u00b6 Go\u2019s for loop is versatile : Traditional for with init; condition; post for as a while loop ( for condition { ... } ) Infinite loop ( for { ... } ) This flexibility makes Go loops simple and powerful . Forever If you omit the loop condition it loops forever, so an infinite loop is compactly expressed. package main func main () { for { } } If Statements \u00b6 In Go, if statements are similar to for loops in syntax: The condition does not require parentheses () . Braces {} are required , even for single-line blocks. Example \u00b6 package main import ( \"fmt\" \"math\" ) func sqrt ( x float64 ) string { if x < 0 { return sqrt ( - x ) + \"i\" } return fmt . Sprint ( math . Sqrt ( x )) } func main () { fmt . Println ( sqrt ( 2 ), sqrt ( - 4 )) } Explanation \u00b6 The function sqrt computes the square root of x . The if statement checks if x is negative: If yes, it recursively calls sqrt with -x and appends \"i\" to indicate an imaginary number. If not, it returns the square root of x using math.Sqrt . The fmt.Sprint function converts the float result to a string for consistent return type. Output \u00b6 1.4142135623730951 2 i Key Points \u00b6 Go allows inline if conditions without parentheses: go if x < 0 { ... } * Braces are mandatory and define the scope of the conditional block. * Go supports recursive function calls as shown in the example. If Statement with a Short Statement \u00b6 In Go, an if statement can include a short statement that runs before the condition . Variables declared in this short statement are only in scope within the if block . This is useful for computations that are only needed for the conditional check. Example \u00b6 package main import ( \"fmt\" \"math\" ) func pow ( x , n , lim float64 ) float64 { if v := math . Pow ( x , n ); v < lim { return v } return lim } func main () { fmt . Println ( pow ( 3 , 2 , 10 ), pow ( 3 , 3 , 20 ), ) } Explanation \u00b6 The if statement starts with a short statement: go v := math.Pow(x, n) This computes x raised to the power n and assigns it to v . 2. The condition v < lim is evaluated immediately after the short statement. 3. v is only visible inside the if statement . 4. If v < lim , the function returns v ; otherwise, it returns lim . Output \u00b6 9 20 Key Points \u00b6 Short statements in if allow clean, inline computation before the condition. Scope of variables declared this way is limited to the if block , which helps avoid polluting the outer scope. Example of limited scope: if v := computeSomething (); v > 10 { fmt . Println ( v ) // OK } // fmt.Println(v) // Error: v is undefined here Switch Statement \u00b6 A switch statement in Go is a concise way to write a sequence of if-else statements. It runs the first case whose value matches the switch expression. Unlike C, C++, Java, or JavaScript: Go automatically breaks after the matched case. No explicit break is needed. Switch cases do not have to be constants , and values do not need to be integers. Example \u00b6 package main import ( \"fmt\" \"runtime\" ) func main () { fmt . Print ( \"Go runs on \" ) switch os := runtime . GOOS ; os { case \"darwin\" : fmt . Println ( \"macOS.\" ) case \"linux\" : fmt . Println ( \"Linux.\" ) default : // freebsd, openbsd, plan9, windows... fmt . Printf ( \"%s.\\n\" , os ) } } Explanation \u00b6 os := runtime.GOOS initializes a variable with the operating system name. The switch evaluates os and executes only the first matching case : \"darwin\" \u2192 prints \"macOS.\" \"linux\" \u2192 prints \"Linux.\" default \u2192 prints any other OS. No break statements are required \u2014 Go stops automatically after executing the matching case. Output (Example on Linux) \u00b6 Go runs on Linux . Key Points \u00b6 Go\u2019s switch is more flexible than many other languages: Cases can be any expression , not just constants. Only the matching case executes ; no fallthrough unless explicitly requested with the fallthrough keyword. Variables declared in the switch statement (like os above) are scoped only within the switch . Switch Evaluation Order \u00b6 In Go, switch cases are evaluated from top to bottom . The switch stops at the first case that succeeds \u2014 later cases are not evaluated . Example: go switch i { case 0: case f(): } If i == 0 , the function f() is not called , because the first case matched. Example: Checking Days Until Saturday \u00b6 package main import ( \"fmt\" \"time\" ) func main () { fmt . Println ( \"When's Saturday?\" ) today := time . Now (). Weekday () switch time . Saturday { case today + 0 : fmt . Println ( \"Today.\" ) case today + 1 : fmt . Println ( \"Tomorrow.\" ) case today + 2 : fmt . Println ( \"In two days.\" ) default : fmt . Println ( \"Too far away.\" ) } } Explanation \u00b6 today := time.Now().Weekday() gets the current day of the week. The switch statement checks time.Saturday against relative values: today + 0 \u2192 today today + 1 \u2192 tomorrow today + 2 \u2192 in two days The first case that matches executes, and the switch exits immediately . The default case runs if none of the other cases match. Output (Example) \u00b6 When's Saturday? Tomorrow. Note: In the Go Playground, time.Now() starts at 2009-11-10 23:00:00 UTC . Key Points \u00b6 Go evaluates cases sequentially from top to bottom. Only the first successful case executes . This allows you to include complex expressions in later cases without worrying about unnecessary evaluation. Switch with No Condition \u00b6 A switch without a condition in Go is equivalent to switch true . This allows you to write clean, readable if-then-else chains without nesting multiple if statements. Example \u00b6 package main import ( \"fmt\" \"time\" ) func main () { t := time . Now () switch { case t . Hour () < 12 : fmt . Println ( \"Good morning!\" ) case t . Hour () < 17 : fmt . Println ( \"Good afternoon.\" ) default : fmt . Println ( \"Good evening.\" ) } } Explanation \u00b6 switch { ... } without a condition automatically evaluates each case as a boolean expression . The first case that evaluates to true is executed. The default case runs if no other case matches . This pattern is ideal for multiple conditional branches where only one branch should run. Output (Example) \u00b6 Good afternoon. Output will vary depending on the current system time. Key Points \u00b6 switch without a condition behaves like switch true . Each case is a boolean expression. Only the first true case executes. It improves readability over long chains of if-else if-else statements. Defer Statement \u00b6 In Go, the defer statement postpones the execution of a function until the surrounding function returns . The arguments of the deferred function are evaluated immediately. The function call itself is executed later, just before the function exits. This is often used for cleanup tasks , such as closing files or releasing resources. Example \u00b6 package main import \"fmt\" func main () { defer fmt . Println ( \"world\" ) fmt . Println ( \"hello\" ) } Explanation \u00b6 defer fmt.Println(\"world\") schedules the Println call to run after main returns . fmt.Println(\"hello\") runs immediately. When main is about to exit, the deferred call executes, printing \"world\" . Output \u00b6 hello world Key Points \u00b6 Multiple defer statements are executed in LIFO order (last-in, first-out). Useful for resource cleanup : f , _ := os . Open ( \"file.txt\" ) defer f . Close () // ensures file is closed at the end of the function Arguments are evaluated at the point of defer , but the call happens later . Stacking Defers \u00b6 In Go, deferred function calls are pushed onto a stack . When the surrounding function returns, the deferred calls are executed in last-in, first-out (LIFO) order . This allows you to schedule multiple cleanup or logging tasks and ensures they run in reverse order of their deferral. Example \u00b6 package main import \"fmt\" func main () { fmt . Println ( \"counting\" ) for i := 0 ; i < 10 ; i ++ { defer fmt . Println ( i ) } fmt . Println ( \"done\" ) } Explanation \u00b6 fmt.Println(\"counting\") prints immediately. The for loop defers printing numbers 0 to 9 . Each deferred call is pushed onto the stack . fmt.Println(\"done\") prints next. When main returns, deferred calls execute in reverse order , printing 9 down to 0 . Output \u00b6 counting done 9 8 7 6 5 4 3 2 1 0 Key Points \u00b6 Deferred calls are executed after the surrounding function finishes . They run in LIFO order , so the last deferred function executes first . Useful for: Reversing operations Cleaning up resources in reverse order of acquisition \u2705 You have completed the Defer lesson! You can now move on to the next lesson or explore other Go topics. If and Else \u00b6 In Go, variables declared inside an if short statement are also available inside any associated else block. However, these variables are scoped only within the if and else statements \u2014 they cannot be accessed outside. Example \u00b6 package main import ( \"fmt\" \"math\" ) func pow ( x , n , lim float64 ) float64 { if v := math . Pow ( x , n ); v < lim { return v } else { fmt . Printf ( \"%g >= %g\\n\" , v , lim ) } // can't use v here, though return lim } func main () { fmt . Println ( pow ( 3 , 2 , 10 ), pow ( 3 , 3 , 20 ), ) } Explanation \u00b6 The variable v is declared inside the if statement: go if v := math.Pow(x, n); v < lim { It exists only within the if and else blocks. If v is less than lim , the function returns v . Otherwise, the else block runs and prints a message. After the if-else , v is out of scope \u2014 trying to use it there would cause a compiler error. Output \u00b6 27 >= 20 9 20 Key Points \u00b6 Variables declared in the if short statement ( if v := ...; condition ) are available only within that if and its corresponding else . The else block runs only if the if condition evaluates to false . This makes Go\u2019s if syntax concise and allows safe, scoped variable declarations. \u2705 Summary: Go\u2019s if and else statements can include short variable declarations, which remain local to those blocks \u2014 clean and efficient for conditional logic. Switch Statement \u00b6 A switch statement in Go provides a concise way to handle multiple conditional branches. It\u2019s often cleaner and more readable than writing multiple if\u2013else chains. How It Works \u00b6 A switch runs the first case that matches the condition. Unlike C, C++, or Java, Go does not require a break statement \u2014 it stops automatically after a matching case. Cases don\u2019t have to be constants or integers \u2014 they can be strings, variables, or expressions. Example \u00b6 package main import ( \"fmt\" \"runtime\" ) func main () { fmt . Print ( \"Go runs on \" ) switch os := runtime . GOOS ; os { case \"darwin\" : fmt . Println ( \"macOS.\" ) case \"linux\" : fmt . Println ( \"Linux.\" ) default : // freebsd, openbsd, plan9, windows... fmt . Printf ( \"%s.\\n\" , os ) } } Explanation \u00b6 The short statement os := runtime.GOOS assigns the operating system name. It\u2019s scoped only within the switch . Go compares os against each case : \"darwin\" \u2192 macOS \"linux\" \u2192 Linux default \u2192 all other OS names The first matching case runs, and Go automatically breaks afterward. Possible Outputs \u00b6 Depending on your system: Go runs on Linux . or Go runs on macOS . or Go runs on windows . Key Points \u00b6 No need for manual break \u2014 it\u2019s implicit. Cases can evaluate any type of expression . Short variable declarations (like os := ... ) are scoped to the switch only. default handles all unmatched cases, similar to the final else . \u2705 Tip: Use switch when checking one value against several possibilities \u2014 it makes code cleaner and easier to read than long if-else chains. \ud83c\udf00 Switch Evaluation Order in Go \u00b6 In Go, switch cases are checked from top to bottom , and evaluation stops immediately when a matching case is found \u2014 no further cases are evaluated. Example Code \u00b6 package main import ( \"fmt\" \"time\" ) func main () { fmt . Println ( \"When's Saturday?\" ) today := time . Now (). Weekday () switch time . Saturday { case today + 0 : fmt . Println ( \"Today.\" ) case today + 1 : fmt . Println ( \"Tomorrow.\" ) case today + 2 : fmt . Println ( \"In two days.\" ) default : fmt . Println ( \"Too far away.\" ) } } Explanation \u00b6 today := time.Now().Weekday() \u2192 gets the current day of the week (like Monday , Tuesday , etc.). The switch compares time.Saturday to each case in order : today + 0 \u2192 means today is Saturday . today + 1 \u2192 means Saturday is tomorrow . today + 2 \u2192 means Saturday is in two days . Otherwise \u2192 \"Too far away.\" Go stops evaluating after the first matching case \u2014 it does not check further. Example Outputs \u00b6 If today is Friday : When's Saturday? Tomorrow. If today is Saturday : When's Saturday? Today. If today is Tuesday : When's Saturday? Too far away. \u2699\ufe0f Key Concepts \u00b6 Switches evaluate top to bottom . Go stops after the first successful match (no \u201cfallthrough\u201d unless explicitly stated). Each case can be an expression , not just a constant. The default clause runs if no other case matches. \ud83d\udca1 Trivia: In the Go Playground, time.Now() is always 2009-11-10 23:00:00 UTC \u2014 it\u2019s a fixed date for deterministic program output. So in that environment, the day is Tuesday , making the output always: When's Saturday? Too far away. \ud83c\udf07 Switch with No Condition in Go \u00b6 A switch without a condition in Go is equivalent to writing: switch true { This allows each case to act as a boolean expression \u2014 similar to a clean, readable if-else if-else chain. Example Code \u00b6 package main import ( \"fmt\" \"time\" ) func main () { t := time . Now () switch { case t . Hour () < 12 : fmt . Println ( \"Good morning!\" ) case t . Hour () < 17 : fmt . Println ( \"Good afternoon.\" ) default : fmt . Println ( \"Good evening.\" ) } } Explanation \u00b6 t := time.Now() \u2192 captures the current system time. The switch has no condition , so Go automatically treats it as switch true . Each case is evaluated in order : If t.Hour() < 12 , prints \"Good morning!\" Else if t.Hour() < 17 , prints \"Good afternoon.\" Otherwise, \"Good evening.\" Once a matching case is found, Go exits the switch \u2014 no further cases are checked. Example Outputs \u00b6 If the current time is: Time (24h) Output 09:45 Good morning! 14:30 Good afternoon. 20:10 Good evening. \u2699\ufe0f Key Points \u00b6 switch without a condition is shorthand for switch true . Makes long if-else chains more compact and readable . Each case should be a boolean expression . Execution stops after the first true case. \ud83d\udca1 Tip: You can use this style for multiple complex conditions \u2014 it keeps your Go code simple, expressive, and elegant. \ud83d\udd52 Defer in Go \u00b6 A defer statement postpones the execution of a function until the surrounding function returns . When you call defer , the arguments are evaluated immediately, but the function call itself is executed later \u2014 right before the function exits. Example Code \u00b6 package main import \"fmt\" func main () { defer fmt . Println ( \"world\" ) fmt . Println ( \"hello\" ) } Explanation \u00b6 defer fmt.Println(\"world\") \u2192 schedules \"world\" to be printed after main() finishes. fmt.Println(\"hello\") \u2192 executes immediately and prints \"hello\" . Once main() is about to exit, Go executes the deferred statement, printing \"world\" . Output \u00b6 hello world \u2699\ufe0f Key Points \u00b6 defer is executed after the surrounding function ends. Arguments are evaluated immediately when the defer is declared. Useful for tasks like: Closing files ( defer file.Close() ) Unlocking mutexes Releasing network connections or database resources \ud83d\udca1 Tip: Think of defer as a \u201c cleanup-on-exit \u201d mechanism \u2014 perfect for writing cleaner, safer Go code. \ud83d\udd01 Stacking defer in Go \u00b6 In Go, deferred function calls are pushed onto a stack . When the surrounding function ( main , in this case) returns, deferred calls are executed in last-in-first-out (LIFO) order \u2014 like popping items from a stack. Example Code \u00b6 package main import \"fmt\" func main () { fmt . Println ( \"counting\" ) for i := 0 ; i < 10 ; i ++ { defer fmt . Println ( i ) } fmt . Println ( \"done\" ) } Explanation \u00b6 The loop runs from i = 0 to i = 9 . Each time, it defers fmt.Println(i) \u2014 adding it to the stack. When the loop finishes, all 10 deferred calls are stacked. As main() returns: Go pops and executes each deferred call in reverse order . Execution Order \u00b6 Step Action Output 1 Print \"counting\" counting 2 Loop defers 10 print calls (nothing yet) 3 Print \"done\" done 4 Execute defers (LIFO) 9 \u2192 0 Final Output \u00b6 counting done 9 8 7 6 5 4 3 2 1 0 \ud83e\udde0 Key Takeaways \u00b6 Deferred calls execute after the function finishes. LIFO order: last deferred \u2192 executed first. Commonly used for cleanup in reverse order , like: go defer conn.Close() defer file.Close() \ud83d\udca1 Analogy: Think of defer as \u201cstacking up cleanup tasks\u201d \u2014 when you leave the room (function), you clean up everything you stacked, in reverse order.","title":"Overview"},{"location":"controlflowstatements/#for-loops-in-go","text":"Go has only one looping construct : the for loop. The basic for loop consists of three components separated by semicolons: Initialization statement \u2013 executed before the first iteration Condition expression \u2013 evaluated before every iteration Post statement \u2013 executed at the end of each iteration","title":"For Loops in Go"},{"location":"controlflowstatements/#how-it-works","text":"The init statement is commonly a short variable declaration. Variables declared here are visible only within the scope of the for loop . The loop continues to execute as long as the condition is true . Once the condition evaluates to false , the loop stops. Unlike C, Java, or JavaScript: There are no parentheses around the components. The curly braces {} are mandatory , even for single-line loops.","title":"How it Works"},{"location":"controlflowstatements/#example","text":"package main import \"fmt\" func main () { sum := 0 for i := 0 ; i < 10 ; i ++ { sum += i } fmt . Println ( sum ) } Explanation: i := 0 initializes the counter. The loop runs while i < 10 . After each iteration, i++ increments i by 1. The loop accumulates the sum of numbers from 0 to 9. Output: 45","title":"Example"},{"location":"controlflowstatements/#for-continued","text":"In Go, the init and post statements in a for loop are optional . You can omit one or both, depending on the logic you need.","title":"For (continued)"},{"location":"controlflowstatements/#example_1","text":"package main import \"fmt\" func main () { sum := 1 for ; sum < 10 ; { sum += sum } fmt . Println ( sum ) }","title":"Example"},{"location":"controlflowstatements/#explanation","text":"The init and post sections are left empty. Only the condition ( sum < 10 ) remains between the semicolons. This is perfectly valid Go syntax and works just like a while loop in other languages. The above example doubles the value of sum until it is no longer less than 10.","title":"Explanation"},{"location":"controlflowstatements/#output","text":"16","title":"Output"},{"location":"controlflowstatements/#tip","text":"If both the init and post statements are omitted, the semicolons themselves can also be removed \u2014 turning it into Go\u2019s while-style loop: for sum < 10 { sum += sum }","title":"Tip"},{"location":"controlflowstatements/#for-continued_1","text":"The init and post statements in a Go for loop are optional . If you omit them, the for loop still works \u2014 it simply becomes more flexible, resembling a while loop in other languages.","title":"For (continued)"},{"location":"controlflowstatements/#example_2","text":"package main import \"fmt\" func main () { sum := 1 for ; sum < 10 ; { sum += sum } fmt . Println ( sum ) }","title":"Example"},{"location":"controlflowstatements/#explanation_1","text":"The init and post statements are left empty ( ; marks their positions). This means: There is no initialization before the loop starts. There is no automatic update after each iteration. The loop runs as long as the condition sum < 10 is true . Here\u2019s what happens step by step: Step Value of sum Condition ( sum < 10 ) Action 1 1 true sum += sum \u2192 2 2 2 true sum += sum \u2192 4 3 4 true sum += sum \u2192 8 4 8 true sum += sum \u2192 16 5 16 false Loop ends","title":"Explanation"},{"location":"controlflowstatements/#output_1","text":"16","title":"Output"},{"location":"controlflowstatements/#key-insight","text":"When you omit both the init and post parts, the for loop in Go acts like a while loop in other languages. Equivalent while-style syntax in pseudocode: for sum < 10 { sum += sum } This demonstrates Go\u2019s flexibility \u2014 you can use for in multiple forms, including the traditional C-style loop or simplified while-like loops.","title":"Key Insight"},{"location":"controlflowstatements/#for-as-gos-while","text":"In Go, there is no separate while loop . You can use a for loop without semicolons to achieve the same behavior. This makes the for loop Go\u2019s equivalent of while in other languages like C or Java.","title":"For as Go's \"While\""},{"location":"controlflowstatements/#example_3","text":"package main import \"fmt\" func main () { sum := 1 for sum < 1000 { sum += sum } fmt . Println ( sum ) }","title":"Example"},{"location":"controlflowstatements/#explanation_2","text":"The condition sum < 1000 is checked before each iteration. There are no init or post statements ; the semicolons are omitted. The loop continues as long as the condition is true . Each iteration doubles the value of sum .","title":"Explanation"},{"location":"controlflowstatements/#output_2","text":"1024","title":"Output"},{"location":"controlflowstatements/#key-insight_1","text":"Go\u2019s for loop is versatile : Traditional for with init; condition; post for as a while loop ( for condition { ... } ) Infinite loop ( for { ... } ) This flexibility makes Go loops simple and powerful . Forever If you omit the loop condition it loops forever, so an infinite loop is compactly expressed. package main func main () { for { } }","title":"Key Insight"},{"location":"controlflowstatements/#if-statements","text":"In Go, if statements are similar to for loops in syntax: The condition does not require parentheses () . Braces {} are required , even for single-line blocks.","title":"If Statements"},{"location":"controlflowstatements/#example_4","text":"package main import ( \"fmt\" \"math\" ) func sqrt ( x float64 ) string { if x < 0 { return sqrt ( - x ) + \"i\" } return fmt . Sprint ( math . Sqrt ( x )) } func main () { fmt . Println ( sqrt ( 2 ), sqrt ( - 4 )) }","title":"Example"},{"location":"controlflowstatements/#explanation_3","text":"The function sqrt computes the square root of x . The if statement checks if x is negative: If yes, it recursively calls sqrt with -x and appends \"i\" to indicate an imaginary number. If not, it returns the square root of x using math.Sqrt . The fmt.Sprint function converts the float result to a string for consistent return type.","title":"Explanation"},{"location":"controlflowstatements/#output_3","text":"1.4142135623730951 2 i","title":"Output"},{"location":"controlflowstatements/#key-points","text":"Go allows inline if conditions without parentheses: go if x < 0 { ... } * Braces are mandatory and define the scope of the conditional block. * Go supports recursive function calls as shown in the example.","title":"Key Points"},{"location":"controlflowstatements/#if-statement-with-a-short-statement","text":"In Go, an if statement can include a short statement that runs before the condition . Variables declared in this short statement are only in scope within the if block . This is useful for computations that are only needed for the conditional check.","title":"If Statement with a Short Statement"},{"location":"controlflowstatements/#example_5","text":"package main import ( \"fmt\" \"math\" ) func pow ( x , n , lim float64 ) float64 { if v := math . Pow ( x , n ); v < lim { return v } return lim } func main () { fmt . Println ( pow ( 3 , 2 , 10 ), pow ( 3 , 3 , 20 ), ) }","title":"Example"},{"location":"controlflowstatements/#explanation_4","text":"The if statement starts with a short statement: go v := math.Pow(x, n) This computes x raised to the power n and assigns it to v . 2. The condition v < lim is evaluated immediately after the short statement. 3. v is only visible inside the if statement . 4. If v < lim , the function returns v ; otherwise, it returns lim .","title":"Explanation"},{"location":"controlflowstatements/#output_4","text":"9 20","title":"Output"},{"location":"controlflowstatements/#key-points_1","text":"Short statements in if allow clean, inline computation before the condition. Scope of variables declared this way is limited to the if block , which helps avoid polluting the outer scope. Example of limited scope: if v := computeSomething (); v > 10 { fmt . Println ( v ) // OK } // fmt.Println(v) // Error: v is undefined here","title":"Key Points"},{"location":"controlflowstatements/#switch-statement","text":"A switch statement in Go is a concise way to write a sequence of if-else statements. It runs the first case whose value matches the switch expression. Unlike C, C++, Java, or JavaScript: Go automatically breaks after the matched case. No explicit break is needed. Switch cases do not have to be constants , and values do not need to be integers.","title":"Switch Statement"},{"location":"controlflowstatements/#example_6","text":"package main import ( \"fmt\" \"runtime\" ) func main () { fmt . Print ( \"Go runs on \" ) switch os := runtime . GOOS ; os { case \"darwin\" : fmt . Println ( \"macOS.\" ) case \"linux\" : fmt . Println ( \"Linux.\" ) default : // freebsd, openbsd, plan9, windows... fmt . Printf ( \"%s.\\n\" , os ) } }","title":"Example"},{"location":"controlflowstatements/#explanation_5","text":"os := runtime.GOOS initializes a variable with the operating system name. The switch evaluates os and executes only the first matching case : \"darwin\" \u2192 prints \"macOS.\" \"linux\" \u2192 prints \"Linux.\" default \u2192 prints any other OS. No break statements are required \u2014 Go stops automatically after executing the matching case.","title":"Explanation"},{"location":"controlflowstatements/#output-example-on-linux","text":"Go runs on Linux .","title":"Output (Example on Linux)"},{"location":"controlflowstatements/#key-points_2","text":"Go\u2019s switch is more flexible than many other languages: Cases can be any expression , not just constants. Only the matching case executes ; no fallthrough unless explicitly requested with the fallthrough keyword. Variables declared in the switch statement (like os above) are scoped only within the switch .","title":"Key Points"},{"location":"controlflowstatements/#switch-evaluation-order","text":"In Go, switch cases are evaluated from top to bottom . The switch stops at the first case that succeeds \u2014 later cases are not evaluated . Example: go switch i { case 0: case f(): } If i == 0 , the function f() is not called , because the first case matched.","title":"Switch Evaluation Order"},{"location":"controlflowstatements/#example-checking-days-until-saturday","text":"package main import ( \"fmt\" \"time\" ) func main () { fmt . Println ( \"When's Saturday?\" ) today := time . Now (). Weekday () switch time . Saturday { case today + 0 : fmt . Println ( \"Today.\" ) case today + 1 : fmt . Println ( \"Tomorrow.\" ) case today + 2 : fmt . Println ( \"In two days.\" ) default : fmt . Println ( \"Too far away.\" ) } }","title":"Example: Checking Days Until Saturday"},{"location":"controlflowstatements/#explanation_6","text":"today := time.Now().Weekday() gets the current day of the week. The switch statement checks time.Saturday against relative values: today + 0 \u2192 today today + 1 \u2192 tomorrow today + 2 \u2192 in two days The first case that matches executes, and the switch exits immediately . The default case runs if none of the other cases match.","title":"Explanation"},{"location":"controlflowstatements/#output-example","text":"When's Saturday? Tomorrow. Note: In the Go Playground, time.Now() starts at 2009-11-10 23:00:00 UTC .","title":"Output (Example)"},{"location":"controlflowstatements/#key-points_3","text":"Go evaluates cases sequentially from top to bottom. Only the first successful case executes . This allows you to include complex expressions in later cases without worrying about unnecessary evaluation.","title":"Key Points"},{"location":"controlflowstatements/#switch-with-no-condition","text":"A switch without a condition in Go is equivalent to switch true . This allows you to write clean, readable if-then-else chains without nesting multiple if statements.","title":"Switch with No Condition"},{"location":"controlflowstatements/#example_7","text":"package main import ( \"fmt\" \"time\" ) func main () { t := time . Now () switch { case t . Hour () < 12 : fmt . Println ( \"Good morning!\" ) case t . Hour () < 17 : fmt . Println ( \"Good afternoon.\" ) default : fmt . Println ( \"Good evening.\" ) } }","title":"Example"},{"location":"controlflowstatements/#explanation_7","text":"switch { ... } without a condition automatically evaluates each case as a boolean expression . The first case that evaluates to true is executed. The default case runs if no other case matches . This pattern is ideal for multiple conditional branches where only one branch should run.","title":"Explanation"},{"location":"controlflowstatements/#output-example_1","text":"Good afternoon. Output will vary depending on the current system time.","title":"Output (Example)"},{"location":"controlflowstatements/#key-points_4","text":"switch without a condition behaves like switch true . Each case is a boolean expression. Only the first true case executes. It improves readability over long chains of if-else if-else statements.","title":"Key Points"},{"location":"controlflowstatements/#defer-statement","text":"In Go, the defer statement postpones the execution of a function until the surrounding function returns . The arguments of the deferred function are evaluated immediately. The function call itself is executed later, just before the function exits. This is often used for cleanup tasks , such as closing files or releasing resources.","title":"Defer Statement"},{"location":"controlflowstatements/#example_8","text":"package main import \"fmt\" func main () { defer fmt . Println ( \"world\" ) fmt . Println ( \"hello\" ) }","title":"Example"},{"location":"controlflowstatements/#explanation_8","text":"defer fmt.Println(\"world\") schedules the Println call to run after main returns . fmt.Println(\"hello\") runs immediately. When main is about to exit, the deferred call executes, printing \"world\" .","title":"Explanation"},{"location":"controlflowstatements/#output_5","text":"hello world","title":"Output"},{"location":"controlflowstatements/#key-points_5","text":"Multiple defer statements are executed in LIFO order (last-in, first-out). Useful for resource cleanup : f , _ := os . Open ( \"file.txt\" ) defer f . Close () // ensures file is closed at the end of the function Arguments are evaluated at the point of defer , but the call happens later .","title":"Key Points"},{"location":"controlflowstatements/#stacking-defers","text":"In Go, deferred function calls are pushed onto a stack . When the surrounding function returns, the deferred calls are executed in last-in, first-out (LIFO) order . This allows you to schedule multiple cleanup or logging tasks and ensures they run in reverse order of their deferral.","title":"Stacking Defers"},{"location":"controlflowstatements/#example_9","text":"package main import \"fmt\" func main () { fmt . Println ( \"counting\" ) for i := 0 ; i < 10 ; i ++ { defer fmt . Println ( i ) } fmt . Println ( \"done\" ) }","title":"Example"},{"location":"controlflowstatements/#explanation_9","text":"fmt.Println(\"counting\") prints immediately. The for loop defers printing numbers 0 to 9 . Each deferred call is pushed onto the stack . fmt.Println(\"done\") prints next. When main returns, deferred calls execute in reverse order , printing 9 down to 0 .","title":"Explanation"},{"location":"controlflowstatements/#output_6","text":"counting done 9 8 7 6 5 4 3 2 1 0","title":"Output"},{"location":"controlflowstatements/#key-points_6","text":"Deferred calls are executed after the surrounding function finishes . They run in LIFO order , so the last deferred function executes first . Useful for: Reversing operations Cleaning up resources in reverse order of acquisition \u2705 You have completed the Defer lesson! You can now move on to the next lesson or explore other Go topics.","title":"Key Points"},{"location":"controlflowstatements/#if-and-else","text":"In Go, variables declared inside an if short statement are also available inside any associated else block. However, these variables are scoped only within the if and else statements \u2014 they cannot be accessed outside.","title":"If and Else"},{"location":"controlflowstatements/#example_10","text":"package main import ( \"fmt\" \"math\" ) func pow ( x , n , lim float64 ) float64 { if v := math . Pow ( x , n ); v < lim { return v } else { fmt . Printf ( \"%g >= %g\\n\" , v , lim ) } // can't use v here, though return lim } func main () { fmt . Println ( pow ( 3 , 2 , 10 ), pow ( 3 , 3 , 20 ), ) }","title":"Example"},{"location":"controlflowstatements/#explanation_10","text":"The variable v is declared inside the if statement: go if v := math.Pow(x, n); v < lim { It exists only within the if and else blocks. If v is less than lim , the function returns v . Otherwise, the else block runs and prints a message. After the if-else , v is out of scope \u2014 trying to use it there would cause a compiler error.","title":"Explanation"},{"location":"controlflowstatements/#output_7","text":"27 >= 20 9 20","title":"Output"},{"location":"controlflowstatements/#key-points_7","text":"Variables declared in the if short statement ( if v := ...; condition ) are available only within that if and its corresponding else . The else block runs only if the if condition evaluates to false . This makes Go\u2019s if syntax concise and allows safe, scoped variable declarations. \u2705 Summary: Go\u2019s if and else statements can include short variable declarations, which remain local to those blocks \u2014 clean and efficient for conditional logic.","title":"Key Points"},{"location":"controlflowstatements/#switch-statement_1","text":"A switch statement in Go provides a concise way to handle multiple conditional branches. It\u2019s often cleaner and more readable than writing multiple if\u2013else chains.","title":"Switch Statement"},{"location":"controlflowstatements/#how-it-works_1","text":"A switch runs the first case that matches the condition. Unlike C, C++, or Java, Go does not require a break statement \u2014 it stops automatically after a matching case. Cases don\u2019t have to be constants or integers \u2014 they can be strings, variables, or expressions.","title":"How It Works"},{"location":"controlflowstatements/#example_11","text":"package main import ( \"fmt\" \"runtime\" ) func main () { fmt . Print ( \"Go runs on \" ) switch os := runtime . GOOS ; os { case \"darwin\" : fmt . Println ( \"macOS.\" ) case \"linux\" : fmt . Println ( \"Linux.\" ) default : // freebsd, openbsd, plan9, windows... fmt . Printf ( \"%s.\\n\" , os ) } }","title":"Example"},{"location":"controlflowstatements/#explanation_11","text":"The short statement os := runtime.GOOS assigns the operating system name. It\u2019s scoped only within the switch . Go compares os against each case : \"darwin\" \u2192 macOS \"linux\" \u2192 Linux default \u2192 all other OS names The first matching case runs, and Go automatically breaks afterward.","title":"Explanation"},{"location":"controlflowstatements/#possible-outputs","text":"Depending on your system: Go runs on Linux . or Go runs on macOS . or Go runs on windows .","title":"Possible Outputs"},{"location":"controlflowstatements/#key-points_8","text":"No need for manual break \u2014 it\u2019s implicit. Cases can evaluate any type of expression . Short variable declarations (like os := ... ) are scoped to the switch only. default handles all unmatched cases, similar to the final else . \u2705 Tip: Use switch when checking one value against several possibilities \u2014 it makes code cleaner and easier to read than long if-else chains.","title":"Key Points"},{"location":"controlflowstatements/#switch-evaluation-order-in-go","text":"In Go, switch cases are checked from top to bottom , and evaluation stops immediately when a matching case is found \u2014 no further cases are evaluated.","title":"\ud83c\udf00 Switch Evaluation Order in Go"},{"location":"controlflowstatements/#example-code","text":"package main import ( \"fmt\" \"time\" ) func main () { fmt . Println ( \"When's Saturday?\" ) today := time . Now (). Weekday () switch time . Saturday { case today + 0 : fmt . Println ( \"Today.\" ) case today + 1 : fmt . Println ( \"Tomorrow.\" ) case today + 2 : fmt . Println ( \"In two days.\" ) default : fmt . Println ( \"Too far away.\" ) } }","title":"Example Code"},{"location":"controlflowstatements/#explanation_12","text":"today := time.Now().Weekday() \u2192 gets the current day of the week (like Monday , Tuesday , etc.). The switch compares time.Saturday to each case in order : today + 0 \u2192 means today is Saturday . today + 1 \u2192 means Saturday is tomorrow . today + 2 \u2192 means Saturday is in two days . Otherwise \u2192 \"Too far away.\" Go stops evaluating after the first matching case \u2014 it does not check further.","title":"Explanation"},{"location":"controlflowstatements/#example-outputs","text":"If today is Friday : When's Saturday? Tomorrow. If today is Saturday : When's Saturday? Today. If today is Tuesday : When's Saturday? Too far away.","title":"Example Outputs"},{"location":"controlflowstatements/#key-concepts","text":"Switches evaluate top to bottom . Go stops after the first successful match (no \u201cfallthrough\u201d unless explicitly stated). Each case can be an expression , not just a constant. The default clause runs if no other case matches. \ud83d\udca1 Trivia: In the Go Playground, time.Now() is always 2009-11-10 23:00:00 UTC \u2014 it\u2019s a fixed date for deterministic program output. So in that environment, the day is Tuesday , making the output always: When's Saturday? Too far away.","title":"\u2699\ufe0f Key Concepts"},{"location":"controlflowstatements/#switch-with-no-condition-in-go","text":"A switch without a condition in Go is equivalent to writing: switch true { This allows each case to act as a boolean expression \u2014 similar to a clean, readable if-else if-else chain.","title":"\ud83c\udf07 Switch with No Condition in Go"},{"location":"controlflowstatements/#example-code_1","text":"package main import ( \"fmt\" \"time\" ) func main () { t := time . Now () switch { case t . Hour () < 12 : fmt . Println ( \"Good morning!\" ) case t . Hour () < 17 : fmt . Println ( \"Good afternoon.\" ) default : fmt . Println ( \"Good evening.\" ) } }","title":"Example Code"},{"location":"controlflowstatements/#explanation_13","text":"t := time.Now() \u2192 captures the current system time. The switch has no condition , so Go automatically treats it as switch true . Each case is evaluated in order : If t.Hour() < 12 , prints \"Good morning!\" Else if t.Hour() < 17 , prints \"Good afternoon.\" Otherwise, \"Good evening.\" Once a matching case is found, Go exits the switch \u2014 no further cases are checked.","title":"Explanation"},{"location":"controlflowstatements/#example-outputs_1","text":"If the current time is: Time (24h) Output 09:45 Good morning! 14:30 Good afternoon. 20:10 Good evening.","title":"Example Outputs"},{"location":"controlflowstatements/#key-points_9","text":"switch without a condition is shorthand for switch true . Makes long if-else chains more compact and readable . Each case should be a boolean expression . Execution stops after the first true case. \ud83d\udca1 Tip: You can use this style for multiple complex conditions \u2014 it keeps your Go code simple, expressive, and elegant.","title":"\u2699\ufe0f Key Points"},{"location":"controlflowstatements/#defer-in-go","text":"A defer statement postpones the execution of a function until the surrounding function returns . When you call defer , the arguments are evaluated immediately, but the function call itself is executed later \u2014 right before the function exits.","title":"\ud83d\udd52 Defer in Go"},{"location":"controlflowstatements/#example-code_2","text":"package main import \"fmt\" func main () { defer fmt . Println ( \"world\" ) fmt . Println ( \"hello\" ) }","title":"Example Code"},{"location":"controlflowstatements/#explanation_14","text":"defer fmt.Println(\"world\") \u2192 schedules \"world\" to be printed after main() finishes. fmt.Println(\"hello\") \u2192 executes immediately and prints \"hello\" . Once main() is about to exit, Go executes the deferred statement, printing \"world\" .","title":"Explanation"},{"location":"controlflowstatements/#output_8","text":"hello world","title":"Output"},{"location":"controlflowstatements/#key-points_10","text":"defer is executed after the surrounding function ends. Arguments are evaluated immediately when the defer is declared. Useful for tasks like: Closing files ( defer file.Close() ) Unlocking mutexes Releasing network connections or database resources \ud83d\udca1 Tip: Think of defer as a \u201c cleanup-on-exit \u201d mechanism \u2014 perfect for writing cleaner, safer Go code.","title":"\u2699\ufe0f Key Points"},{"location":"controlflowstatements/#stacking-defer-in-go","text":"In Go, deferred function calls are pushed onto a stack . When the surrounding function ( main , in this case) returns, deferred calls are executed in last-in-first-out (LIFO) order \u2014 like popping items from a stack.","title":"\ud83d\udd01 Stacking defer in Go"},{"location":"controlflowstatements/#example-code_3","text":"package main import \"fmt\" func main () { fmt . Println ( \"counting\" ) for i := 0 ; i < 10 ; i ++ { defer fmt . Println ( i ) } fmt . Println ( \"done\" ) }","title":"Example Code"},{"location":"controlflowstatements/#explanation_15","text":"The loop runs from i = 0 to i = 9 . Each time, it defers fmt.Println(i) \u2014 adding it to the stack. When the loop finishes, all 10 deferred calls are stacked. As main() returns: Go pops and executes each deferred call in reverse order .","title":"Explanation"},{"location":"controlflowstatements/#execution-order","text":"Step Action Output 1 Print \"counting\" counting 2 Loop defers 10 print calls (nothing yet) 3 Print \"done\" done 4 Execute defers (LIFO) 9 \u2192 0","title":"Execution Order"},{"location":"controlflowstatements/#final-output","text":"counting done 9 8 7 6 5 4 3 2 1 0","title":"Final Output"},{"location":"controlflowstatements/#key-takeaways","text":"Deferred calls execute after the function finishes. LIFO order: last deferred \u2192 executed first. Commonly used for cleanup in reverse order , like: go defer conn.Close() defer file.Close() \ud83d\udca1 Analogy: Think of defer as \u201cstacking up cleanup tasks\u201d \u2014 when you leave the room (function), you clean up everything you stacked, in reverse order.","title":"\ud83e\udde0 Key Takeaways"},{"location":"questions/","text":"While direct community-driven localization for the official Go documentation isn't a standard, immediate process like for some other projects, your contribution of Swahili localization would be valuable and likely welcomed through the established Go contribution process, especially for the Go Wiki or specific non-core documentation. The Go project uses a rigorous contribution workflow centered around Gerrit, rather than typical GitHub Pull Requests, for core projects like the main documentation. Here is the step-by-step process you should follow, focusing on the Go community's official channels: 1. \ud83d\udce7 Determine the Best Project and Discuss \u00b6 Localization efforts for documentation often start as a community project or are managed in a separate repository under the golang.org/x/ umbrella (for extra tools/repos). Consult the Go Wiki: Check the Go Wiki and the go.googlesource.com/website repository (which serves the Go website and documentation) for any existing information about localization efforts or a specific localization/i18n repository. Start a Discussion: The most critical first step is to propose your idea to the Go community to ensure your effort is coordinated and approved. Mailing List: The golang-dev or golang-nuts mailing lists are the official channels for proposing changes and discussing development. Search them first for existing localization discussions and then post your proposal for Swahili localization. Issue Tracker: If you can't find a localization process, you might consider opening an issue in the Go issue tracker (using the prefix wiki: or similar if targeting documentation) to propose the new language addition and ask for guidance on the correct repository and workflow. 2. \ud83d\udcdd Complete Official Contribution Prerequisites \u00b6 Before submitting any changes to an official Go project, you must complete the legal and technical setup: Contributor License Agreement (CLA): You must sign and submit a CLA to Google, granting them the rights to use your contributions. This is mandatory for all contributions. Gerrit Registration: The Go project uses Gerrit for code review (not GitHub Pull Requests for core repositories). Generate Credentials: Visit go.googlesource.com , click \"Generate Password,\" and follow the instructions to set up authentication. Register: Visit the Gerrit registration page to register your account. Install git-codereview : This tool helps format your commits for Gerrit. Run: bash go install golang.org/x/review/git-codereview@latest 3. \ud83d\udee0\ufe0f Clone the Repository \u00b6 Once you have clarity on where to contribute (likely the go.googlesource.com/website repo or a designated localization repo/wiki), clone the source: # Clone the website repository (where much of the documentation lives) git clone https://go.googlesource.com/website cd website 4. \u270d\ufe0f Create and Submit Your Swahili Localization \u00b6 The process for translation usually involves creating a new directory structure for the language tag, which for Swahili would be sw or sw-TZ (Tanzania) / sw-KE (Kenya) depending on the accepted language code. You'll need to check the existing structure for other languages. Create a New Branch: bash git checkout -b swahili-docs-localization Add Translation Files: Create the necessary Swahili-localized documentation files based on the structure of the English documentation and any existing localized versions. Commit Your Changes: Use the special git codereview tool for committing: bash git add [your new or modified files] git codereview change # Write a clear commit message in the editor that opens. Upload to Gerrit: Use the git codereview tool to submit your change for review: bash git codereview mail A reviewer from the Go team will examine your change on Gerrit and provide feedback until your Swahili localization is ready to be merged. what is GOPATH and what does it mean? How are languages programming languages playgrounds made? What are golang packages and how they work. Create a golang calculator using packages. what are modules and packages in golang and what are their difference with real world examples. That's a great set of questions covering fundamental concepts in Go development! Here are the answers, followed by a complete Go calculator example using packages. \ud83d\udcbb GOPATH : Definition and Meaning \u00b6 The term GOPATH historically referred to an environment variable that set the root directory for your Go workspace. While it is no longer strictly necessary since the introduction of Go Modules in Go 1.11, understanding what it meant is crucial for comprehending Go's evolution. What it Was: \u00b6 GOPATH defined the workspace where Go tools looked for: Source Code ( src ): Where your Go source files and the source files of external dependencies were located (e.g., $GOPATH/src/github.com/user/project ). Compiled Packages ( pkg ): Where precompiled package objects were stored. Installed Commands ( bin ): Where executable binaries were placed after running go install . What it Means (Today): \u00b6 Today, the meaning of GOPATH is that of a legacy organizational structure . For modern projects using Go Modules, the location of the project can be anywhere, and the dependency management is handled by the go.mod file. The only remaining key use of GOPATH is to specify the location of the Go toolchain's binaries (via $GOPATH/bin ) and the Global Module Cache (often under $GOPATH/pkg/mod ), which is where all downloaded module dependencies are stored globally. \ud83c\udfae How Programming Language Playgrounds Are Made \u00b6 Programming language playgrounds (like the Go Playground) are interactive web environments that let users write, compile, and run code directly in their browser without any local setup. They generally work using these core components: Frontend (Browser): An editor (often using libraries like CodeMirror or Monaco ) captures the user's code. A JavaScript handler sends the code as a string via HTTP POST request to the backend server. Backend (Server): The server receives the code. Sandboxing: This is the most critical security step. The code is executed within an isolated, resource-limited container (like a Docker container or a dedicated virtual machine). This prevents malicious code from accessing the server's file system or consuming excessive resources. Compilation/Interpretation: The language's compiler (e.g., the Go compiler) or interpreter is invoked on the sandboxed code. Execution: The compiled/interpreted code is run within the sandbox. Result Delivery: The backend captures the program's output ( stdout and stderr ). The output (and any compilation errors) is sent back to the browser as a JSON response. Frontend Display: The browser receives the JSON and updates the output panel for the user. \ud83d\udce6 Go Packages and How They Work \u00b6 What are Go Packages? \u00b6 A Go package is the fundamental way of organizing and reusing code in Go. Every Go program is made up of packages. A directory containing Go source files ( .go files) is treated as a single package. All files in the same directory must declare the same package name at the top. The package named main is special\u2014it defines a standalone executable program, starting with the main() function. How They Work: \u00b6 Concept Description Encapsulation Items (functions, variables, types) starting with a capital letter (e.g., Add ) are exported (public) and visible to other packages. Items starting with a lowercase letter (e.g., calculate ) are unexported (private) and only accessible within the package they are defined in. Importing To use code from another package, you must use the import keyword followed by the package's import path (e.g., import \"myproject/calculator\" ). Usage Once imported, you access exported functions/variables using the package name prefix and the dot operator (e.g., calculator.Add(5, 3) ). \ud83d\udee0\ufe0f Golang Calculator Using Packages \u00b6 Here is a simple Go calculator project structured using packages. Project Structure: \u00b6 calculator_app / \u251c\u2500\u2500 main . go // Main executable program (package main) \u2514\u2500\u2500 mathops / // Sub-directory for the package \u251c\u2500\u2500 mathops . go // Calculator logic (package mathops) \u2514\u2500\u2500 go . mod // Module file for dependency tracking 1. mathops/mathops.go (The Package) \u00b6 package mathops // Add adds two integers and returns the result. // It is exported (public) because it starts with a capital letter. func Add ( a , b int ) int { return a + b } // Subtract subtracts the second integer from the first. // It is exported (public) because it starts with a capital letter. func Subtract ( a , b int ) int { return a - b } // multiply is a helper function that is NOT exported (private). // It cannot be called from main.go. func multiply ( a , b int ) int { return a * b } 2. main.go (The Executable) \u00b6 package main import ( \"fmt\" // Import the package we created. The path is based on the module name. \"calculator_app/mathops\" ) func main () { a := 10 b := 5 // 1. Use the exported Add function from the mathops package sum := mathops . Add ( a , b ) fmt . Printf ( \"Addition of %d and %d is: %d\\n\" , a , b , sum ) // Output: 15 // 2. Use the exported Subtract function diff := mathops . Subtract ( a , b ) fmt . Printf ( \"Subtraction of %d and %d is: %d\\n\" , a , b , diff ) // Output: 5 // 3. Attempting to use the unexported 'multiply' function would result in an error: // product := mathops.multiply(a, b) // ERROR: cannot refer to unexported name mathops.multiply } 3. Setup and Run: \u00b6 # Initialize the module (crucial for defining the import path) cd calculator_app go mod init calculator_app # Create the mathops directory and files (if you didn't already) mkdir mathops # Run the program go run main.go # Output: # Addition of 10 and 5 is: 15 # Subtraction of 10 and 5 is: 5 \ud83e\uddf1 Go Modules vs. Packages \u00b6 Modules and Packages are both organizational units, but they operate at different levels of a project. 1. Package (The Code Unit) \u00b6 Feature Description Real-World Analogy Scope Code Level - Files that work together (e.g., mathops , database , userhandler ). A single chapter in a textbook, containing related topics and exercises. Definition A collection of Go source files in a single directory. Purpose Code organization, encapsulation, and reuse . Key File .go files containing package [name] . 2. Module (The Project Unit) \u00b6 Feature Description Real-World Analogy Scope Project Level - A versioned collection of packages and dependencies. The entire textbook , which has a title, version number, and a list of references/bibliography. Definition A directory containing a go.mod file. Purpose Dependency management and versioning . It defines the required Go version and external dependencies. Key File go.mod (lists dependencies) and go.sum (verifies dependency integrity). Summary of Differences: \u00b6 Package Module Defined by package keyword in .go files go.mod file Primary Goal Organize your code Manage dependencies Versioned? No Yes (The module itself is versioned) Contains Functions, types, variables Packages (local and external) Real-World Example: \u00b6 Imagine you are building an e-commerce website called ecom-api . Module: The entire ecom-api project is one Module . Its go.mod file lists dependencies like the PostgreSQL driver ( github.com/lib/pq ) and a logging library ( go.uber.org/zap ). Packages: main package: Contains the code that starts the server. order package: Handles order creation, updates, and cancellations. payment package: Handles communication with the payment gateway. user/auth package: Handles login and token generation. The Module ensures the entire project uses the correct, working versions of external dependencies, while the Packages ensure the code is clean, separated, and reusable within the project. Project idea random number generator and scientific calculator. projects using math.sqrt That's an interesting request! I can certainly provide detailed project ideas for a random number generator and a scientific calculator, focusing on the concepts and structure of the Go projects, including where the math.Sqrt function would be used, all without providing the actual Go code . Here are the project ideas, structured using Go packages and modules. \ud83d\udca1 Project Idea 1: Secure Random Number Generator (RNG) \u00b6 This project focuses on providing robust random number generation, which is crucial for simulations, security (cryptography), and unique ID generation. \ud83c\udfaf Goal: \u00b6 Create a Go package that provides various types of high-quality random numbers, leveraging Go's standard library for both fast (pseudo-random) and secure (cryptographically-secure) generation. \ud83d\udce6 Project Structure: \u00b6 rng_project / \u251c\u2500\u2500 main . go // Uses the generator package \u251c\u2500\u2500 generator / // The core package \u2502 \u251c\u2500\u2500 generator . go // Public functions for RNG \u2502 \u2514\u2500\u2500 secure . go // Logic for cryptographically secure RNG \u2514\u2500\u2500 go . mod // Module file \u2699\ufe0f Key Package Functions ( generator package): \u00b6 Function Idea Purpose Math Concepts Involved RandomInt(min, max int) Generates a standard, fast pseudo-random integer within a specified range. Modulo arithmetic, seeding. CryptoInt(max int) Generates a cryptographically secure random integer up to max . Entropy, secure hashing. ShuffleSlice[T any](slice []T) Randomly reorders elements in a slice (e.g., shuffling a deck of cards). Fisher-Yates shuffle algorithm. GaussianFloat64() Generates a floating-point number following a Normal (Gaussian) Distribution . Square Root ( math.Sqrt ) is often used in the Box-Muller transform to convert uniform random variables into Gaussian distributed ones. \ud83d\udee0\ufe0f math.Sqrt Usage in RNG: \u00b6 The math.Sqrt function is essential for generating numbers that follow specific non-uniform distributions. In the Gaussian Float function: Two independent, uniformly distributed random numbers ($U_1$, $U_2$) are generated. The Box-Muller transform requires calculating the square root of a natural logarithm to determine the radial distance from the origin in a 2D plane. The final result uses the output of $\\sqrt{-2 \\ln(U_1)}$ to apply the transformation, making math.Sqrt a core component of this statistical method. \ud83d\udd22 Project Idea 2: Command-Line Scientific Calculator \u00b6 This project creates a command-line tool capable of evaluating complex scientific expressions. It would be implemented with clean package separation for logic and user interface. \ud83c\udfaf Goal: \u00b6 Build a Go application that accepts a mathematical expression as a string (e.g., \"sqrt(25) + sin(90)\" ) and outputs the calculated result. \ud83d\udce6 Project Structure: \u00b6 sci_calc / \u251c\u2500\u2500 main . go // Handles CLI input/output (package main) \u251c\u2500\u2500 parser / // Handles expression analysis \u2502 \u2514\u2500\u2500 parser . go // Tokenization and parsing logic \u2514\u2500\u2500 solver / // Handles mathematical evaluation \u2514\u2500\u2500 solver . go // Core math functions (where math.Sqrt lives) \u2699\ufe0f Key Package Functions ( solver package): \u00b6 Function Idea Purpose Math Concepts Involved Evaluate(expression string) float64 The main function that takes the parsed expression and computes the final value. Operator precedence (PEMDAS). ApplySqrt(value float64) float64 Calculates the square root of the input value. Square Root ( math.Sqrt ). ApplyLog(value float64) float64 Calculates the natural logarithm of the input. Logarithms, base constants. ApplySin(angle float64) float64 Calculates the sine of an angle (handling radians/degrees conversion). Trigonometry, constants ($\\pi$). \ud83d\udee0\ufe0f math.Sqrt Usage in Scientific Calculator: \u00b6 The math.Sqrt function would be directly mapped to the user-facing sqrt() operation. Beyond simple input, it's also critical for more complex internal functions: Direct Calculation: When the parser package identifies the sqrt(X) function call, the solver package uses math.Sqrt(X) to get the result. Hypotenuse/Distance: If you implement a function to calculate the distance between two points ($x_1, y_1$) and ($x_2, y_2$), the formula is $\\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}$. This requires using math.Sqrt . Quadratic Solver: To solve $ax^2 + bx + c = 0$, the quadratic formula requires the square root of the discriminant ($\\sqrt{b^2 - 4ac}$). The solver package would rely on math.Sqrt for this functionality.","title":"Overview"},{"location":"questions/#1-determine-the-best-project-and-discuss","text":"Localization efforts for documentation often start as a community project or are managed in a separate repository under the golang.org/x/ umbrella (for extra tools/repos). Consult the Go Wiki: Check the Go Wiki and the go.googlesource.com/website repository (which serves the Go website and documentation) for any existing information about localization efforts or a specific localization/i18n repository. Start a Discussion: The most critical first step is to propose your idea to the Go community to ensure your effort is coordinated and approved. Mailing List: The golang-dev or golang-nuts mailing lists are the official channels for proposing changes and discussing development. Search them first for existing localization discussions and then post your proposal for Swahili localization. Issue Tracker: If you can't find a localization process, you might consider opening an issue in the Go issue tracker (using the prefix wiki: or similar if targeting documentation) to propose the new language addition and ask for guidance on the correct repository and workflow.","title":"1. \ud83d\udce7 Determine the Best Project and Discuss"},{"location":"questions/#2-complete-official-contribution-prerequisites","text":"Before submitting any changes to an official Go project, you must complete the legal and technical setup: Contributor License Agreement (CLA): You must sign and submit a CLA to Google, granting them the rights to use your contributions. This is mandatory for all contributions. Gerrit Registration: The Go project uses Gerrit for code review (not GitHub Pull Requests for core repositories). Generate Credentials: Visit go.googlesource.com , click \"Generate Password,\" and follow the instructions to set up authentication. Register: Visit the Gerrit registration page to register your account. Install git-codereview : This tool helps format your commits for Gerrit. Run: bash go install golang.org/x/review/git-codereview@latest","title":"2. \ud83d\udcdd Complete Official Contribution Prerequisites"},{"location":"questions/#3-clone-the-repository","text":"Once you have clarity on where to contribute (likely the go.googlesource.com/website repo or a designated localization repo/wiki), clone the source: # Clone the website repository (where much of the documentation lives) git clone https://go.googlesource.com/website cd website","title":"3. \ud83d\udee0\ufe0f Clone the Repository"},{"location":"questions/#4-create-and-submit-your-swahili-localization","text":"The process for translation usually involves creating a new directory structure for the language tag, which for Swahili would be sw or sw-TZ (Tanzania) / sw-KE (Kenya) depending on the accepted language code. You'll need to check the existing structure for other languages. Create a New Branch: bash git checkout -b swahili-docs-localization Add Translation Files: Create the necessary Swahili-localized documentation files based on the structure of the English documentation and any existing localized versions. Commit Your Changes: Use the special git codereview tool for committing: bash git add [your new or modified files] git codereview change # Write a clear commit message in the editor that opens. Upload to Gerrit: Use the git codereview tool to submit your change for review: bash git codereview mail A reviewer from the Go team will examine your change on Gerrit and provide feedback until your Swahili localization is ready to be merged. what is GOPATH and what does it mean? How are languages programming languages playgrounds made? What are golang packages and how they work. Create a golang calculator using packages. what are modules and packages in golang and what are their difference with real world examples. That's a great set of questions covering fundamental concepts in Go development! Here are the answers, followed by a complete Go calculator example using packages.","title":"4. \u270d\ufe0f Create and Submit Your Swahili Localization"},{"location":"questions/#gopath-definition-and-meaning","text":"The term GOPATH historically referred to an environment variable that set the root directory for your Go workspace. While it is no longer strictly necessary since the introduction of Go Modules in Go 1.11, understanding what it meant is crucial for comprehending Go's evolution.","title":"\ud83d\udcbb GOPATH: Definition and Meaning"},{"location":"questions/#what-it-was","text":"GOPATH defined the workspace where Go tools looked for: Source Code ( src ): Where your Go source files and the source files of external dependencies were located (e.g., $GOPATH/src/github.com/user/project ). Compiled Packages ( pkg ): Where precompiled package objects were stored. Installed Commands ( bin ): Where executable binaries were placed after running go install .","title":"What it Was:"},{"location":"questions/#what-it-means-today","text":"Today, the meaning of GOPATH is that of a legacy organizational structure . For modern projects using Go Modules, the location of the project can be anywhere, and the dependency management is handled by the go.mod file. The only remaining key use of GOPATH is to specify the location of the Go toolchain's binaries (via $GOPATH/bin ) and the Global Module Cache (often under $GOPATH/pkg/mod ), which is where all downloaded module dependencies are stored globally.","title":"What it Means (Today):"},{"location":"questions/#how-programming-language-playgrounds-are-made","text":"Programming language playgrounds (like the Go Playground) are interactive web environments that let users write, compile, and run code directly in their browser without any local setup. They generally work using these core components: Frontend (Browser): An editor (often using libraries like CodeMirror or Monaco ) captures the user's code. A JavaScript handler sends the code as a string via HTTP POST request to the backend server. Backend (Server): The server receives the code. Sandboxing: This is the most critical security step. The code is executed within an isolated, resource-limited container (like a Docker container or a dedicated virtual machine). This prevents malicious code from accessing the server's file system or consuming excessive resources. Compilation/Interpretation: The language's compiler (e.g., the Go compiler) or interpreter is invoked on the sandboxed code. Execution: The compiled/interpreted code is run within the sandbox. Result Delivery: The backend captures the program's output ( stdout and stderr ). The output (and any compilation errors) is sent back to the browser as a JSON response. Frontend Display: The browser receives the JSON and updates the output panel for the user.","title":"\ud83c\udfae How Programming Language Playgrounds Are Made"},{"location":"questions/#go-packages-and-how-they-work","text":"","title":"\ud83d\udce6 Go Packages and How They Work"},{"location":"questions/#what-are-go-packages","text":"A Go package is the fundamental way of organizing and reusing code in Go. Every Go program is made up of packages. A directory containing Go source files ( .go files) is treated as a single package. All files in the same directory must declare the same package name at the top. The package named main is special\u2014it defines a standalone executable program, starting with the main() function.","title":"What are Go Packages?"},{"location":"questions/#how-they-work","text":"Concept Description Encapsulation Items (functions, variables, types) starting with a capital letter (e.g., Add ) are exported (public) and visible to other packages. Items starting with a lowercase letter (e.g., calculate ) are unexported (private) and only accessible within the package they are defined in. Importing To use code from another package, you must use the import keyword followed by the package's import path (e.g., import \"myproject/calculator\" ). Usage Once imported, you access exported functions/variables using the package name prefix and the dot operator (e.g., calculator.Add(5, 3) ).","title":"How They Work:"},{"location":"questions/#golang-calculator-using-packages","text":"Here is a simple Go calculator project structured using packages.","title":"\ud83d\udee0\ufe0f Golang Calculator Using Packages"},{"location":"questions/#project-structure","text":"calculator_app / \u251c\u2500\u2500 main . go // Main executable program (package main) \u2514\u2500\u2500 mathops / // Sub-directory for the package \u251c\u2500\u2500 mathops . go // Calculator logic (package mathops) \u2514\u2500\u2500 go . mod // Module file for dependency tracking","title":"Project Structure:"},{"location":"questions/#1-mathopsmathopsgo-the-package","text":"package mathops // Add adds two integers and returns the result. // It is exported (public) because it starts with a capital letter. func Add ( a , b int ) int { return a + b } // Subtract subtracts the second integer from the first. // It is exported (public) because it starts with a capital letter. func Subtract ( a , b int ) int { return a - b } // multiply is a helper function that is NOT exported (private). // It cannot be called from main.go. func multiply ( a , b int ) int { return a * b }","title":"1. mathops/mathops.go (The Package)"},{"location":"questions/#2-maingo-the-executable","text":"package main import ( \"fmt\" // Import the package we created. The path is based on the module name. \"calculator_app/mathops\" ) func main () { a := 10 b := 5 // 1. Use the exported Add function from the mathops package sum := mathops . Add ( a , b ) fmt . Printf ( \"Addition of %d and %d is: %d\\n\" , a , b , sum ) // Output: 15 // 2. Use the exported Subtract function diff := mathops . Subtract ( a , b ) fmt . Printf ( \"Subtraction of %d and %d is: %d\\n\" , a , b , diff ) // Output: 5 // 3. Attempting to use the unexported 'multiply' function would result in an error: // product := mathops.multiply(a, b) // ERROR: cannot refer to unexported name mathops.multiply }","title":"2. main.go (The Executable)"},{"location":"questions/#3-setup-and-run","text":"# Initialize the module (crucial for defining the import path) cd calculator_app go mod init calculator_app # Create the mathops directory and files (if you didn't already) mkdir mathops # Run the program go run main.go # Output: # Addition of 10 and 5 is: 15 # Subtraction of 10 and 5 is: 5","title":"3. Setup and Run:"},{"location":"questions/#go-modules-vs-packages","text":"Modules and Packages are both organizational units, but they operate at different levels of a project.","title":"\ud83e\uddf1 Go Modules vs. Packages"},{"location":"questions/#1-package-the-code-unit","text":"Feature Description Real-World Analogy Scope Code Level - Files that work together (e.g., mathops , database , userhandler ). A single chapter in a textbook, containing related topics and exercises. Definition A collection of Go source files in a single directory. Purpose Code organization, encapsulation, and reuse . Key File .go files containing package [name] .","title":"1. Package (The Code Unit)"},{"location":"questions/#2-module-the-project-unit","text":"Feature Description Real-World Analogy Scope Project Level - A versioned collection of packages and dependencies. The entire textbook , which has a title, version number, and a list of references/bibliography. Definition A directory containing a go.mod file. Purpose Dependency management and versioning . It defines the required Go version and external dependencies. Key File go.mod (lists dependencies) and go.sum (verifies dependency integrity).","title":"2. Module (The Project Unit)"},{"location":"questions/#summary-of-differences","text":"Package Module Defined by package keyword in .go files go.mod file Primary Goal Organize your code Manage dependencies Versioned? No Yes (The module itself is versioned) Contains Functions, types, variables Packages (local and external)","title":"Summary of Differences:"},{"location":"questions/#real-world-example","text":"Imagine you are building an e-commerce website called ecom-api . Module: The entire ecom-api project is one Module . Its go.mod file lists dependencies like the PostgreSQL driver ( github.com/lib/pq ) and a logging library ( go.uber.org/zap ). Packages: main package: Contains the code that starts the server. order package: Handles order creation, updates, and cancellations. payment package: Handles communication with the payment gateway. user/auth package: Handles login and token generation. The Module ensures the entire project uses the correct, working versions of external dependencies, while the Packages ensure the code is clean, separated, and reusable within the project. Project idea random number generator and scientific calculator. projects using math.sqrt That's an interesting request! I can certainly provide detailed project ideas for a random number generator and a scientific calculator, focusing on the concepts and structure of the Go projects, including where the math.Sqrt function would be used, all without providing the actual Go code . Here are the project ideas, structured using Go packages and modules.","title":"Real-World Example:"},{"location":"questions/#project-idea-1-secure-random-number-generator-rng","text":"This project focuses on providing robust random number generation, which is crucial for simulations, security (cryptography), and unique ID generation.","title":"\ud83d\udca1 Project Idea 1: Secure Random Number Generator (RNG)"},{"location":"questions/#goal","text":"Create a Go package that provides various types of high-quality random numbers, leveraging Go's standard library for both fast (pseudo-random) and secure (cryptographically-secure) generation.","title":"\ud83c\udfaf Goal:"},{"location":"questions/#project-structure_1","text":"rng_project / \u251c\u2500\u2500 main . go // Uses the generator package \u251c\u2500\u2500 generator / // The core package \u2502 \u251c\u2500\u2500 generator . go // Public functions for RNG \u2502 \u2514\u2500\u2500 secure . go // Logic for cryptographically secure RNG \u2514\u2500\u2500 go . mod // Module file","title":"\ud83d\udce6 Project Structure:"},{"location":"questions/#key-package-functions-generator-package","text":"Function Idea Purpose Math Concepts Involved RandomInt(min, max int) Generates a standard, fast pseudo-random integer within a specified range. Modulo arithmetic, seeding. CryptoInt(max int) Generates a cryptographically secure random integer up to max . Entropy, secure hashing. ShuffleSlice[T any](slice []T) Randomly reorders elements in a slice (e.g., shuffling a deck of cards). Fisher-Yates shuffle algorithm. GaussianFloat64() Generates a floating-point number following a Normal (Gaussian) Distribution . Square Root ( math.Sqrt ) is often used in the Box-Muller transform to convert uniform random variables into Gaussian distributed ones.","title":"\u2699\ufe0f Key Package Functions (generator package):"},{"location":"questions/#mathsqrt-usage-in-rng","text":"The math.Sqrt function is essential for generating numbers that follow specific non-uniform distributions. In the Gaussian Float function: Two independent, uniformly distributed random numbers ($U_1$, $U_2$) are generated. The Box-Muller transform requires calculating the square root of a natural logarithm to determine the radial distance from the origin in a 2D plane. The final result uses the output of $\\sqrt{-2 \\ln(U_1)}$ to apply the transformation, making math.Sqrt a core component of this statistical method.","title":"\ud83d\udee0\ufe0f math.Sqrt Usage in RNG:"},{"location":"questions/#project-idea-2-command-line-scientific-calculator","text":"This project creates a command-line tool capable of evaluating complex scientific expressions. It would be implemented with clean package separation for logic and user interface.","title":"\ud83d\udd22 Project Idea 2: Command-Line Scientific Calculator"},{"location":"questions/#goal_1","text":"Build a Go application that accepts a mathematical expression as a string (e.g., \"sqrt(25) + sin(90)\" ) and outputs the calculated result.","title":"\ud83c\udfaf Goal:"},{"location":"questions/#project-structure_2","text":"sci_calc / \u251c\u2500\u2500 main . go // Handles CLI input/output (package main) \u251c\u2500\u2500 parser / // Handles expression analysis \u2502 \u2514\u2500\u2500 parser . go // Tokenization and parsing logic \u2514\u2500\u2500 solver / // Handles mathematical evaluation \u2514\u2500\u2500 solver . go // Core math functions (where math.Sqrt lives)","title":"\ud83d\udce6 Project Structure:"},{"location":"questions/#key-package-functions-solver-package","text":"Function Idea Purpose Math Concepts Involved Evaluate(expression string) float64 The main function that takes the parsed expression and computes the final value. Operator precedence (PEMDAS). ApplySqrt(value float64) float64 Calculates the square root of the input value. Square Root ( math.Sqrt ). ApplyLog(value float64) float64 Calculates the natural logarithm of the input. Logarithms, base constants. ApplySin(angle float64) float64 Calculates the sine of an angle (handling radians/degrees conversion). Trigonometry, constants ($\\pi$).","title":"\u2699\ufe0f Key Package Functions (solver package):"},{"location":"questions/#mathsqrt-usage-in-scientific-calculator","text":"The math.Sqrt function would be directly mapped to the user-facing sqrt() operation. Beyond simple input, it's also critical for more complex internal functions: Direct Calculation: When the parser package identifies the sqrt(X) function call, the solver package uses math.Sqrt(X) to get the result. Hypotenuse/Distance: If you implement a function to calculate the distance between two points ($x_1, y_1$) and ($x_2, y_2$), the formula is $\\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}$. This requires using math.Sqrt . Quadratic Solver: To solve $ax^2 + bx + c = 0$, the quadratic formula requires the square root of the discriminant ($\\sqrt{b^2 - 4ac}$). The solver package would rely on math.Sqrt for this functionality.","title":"\ud83d\udee0\ufe0f math.Sqrt Usage in Scientific Calculator:"}]}